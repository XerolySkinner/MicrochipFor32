.TH "DRIVERS" 3 "2022年 十一月 22日 星期二" "Version 1.0.0" "Bscpp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DRIVERS \- Sensor Driver Layer
.PP
 \- Hardware drivers to communicate with sensors via I2C\&.  

.SH SYNOPSIS
.br
.PP
.SS "文件"

.in +1c
.ti -1c
.RI "文件 \fBinv_mpu\&.c\fP"
.br
.RI "An I2C-based driver for Invensense gyroscopes\&. "
.ti -1c
.RI "文件 \fBinv_mpu\&.h\fP"
.br
.RI "An I2C-based driver for Invensense gyroscopes\&. "
.ti -1c
.RI "文件 \fBinv_mpu_dmp_motion_driver\&.c\fP"
.br
.RI "DMP image and interface functions\&. "
.ti -1c
.RI "文件 \fBinv_mpu_dmp_motion_driver\&.h\fP"
.br
.RI "DMP image and interface functions\&. "
.in -1c
.SS "类"

.in +1c
.ti -1c
.RI "struct \fBgyro_reg_s\fP"
.br
.ti -1c
.RI "struct \fBhw_s\fP"
.br
.ti -1c
.RI "struct \fBmotion_int_cache_s\fP"
.br
.ti -1c
.RI "struct \fBchip_cfg_s\fP"
.br
.ti -1c
.RI "struct \fBtest_s\fP"
.br
.ti -1c
.RI "struct \fBgyro_state_s\fP"
.br
.ti -1c
.RI "struct \fBint_param_s\fP"
.br
.ti -1c
.RI "struct \fBdmp_s\fP"
.br
.in -1c
.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fBMPU6050\fP"
.br
.ti -1c
.RI "#define \fBMOTION_DRIVER_TARGET_MSP430\fP"
.br
.ti -1c
.RI "#define \fBi2c_write\fP   \fBMPU_Write_Len\fP"
.br
.ti -1c
.RI "#define \fBi2c_read\fP   \fBMPU_Read_Len\fP"
.br
.ti -1c
.RI "#define \fBdelay_ms\fP   HAL_Delay"
.br
.ti -1c
.RI "#define \fBget_ms\fP   \fBmget_ms\fP"
.br
.ti -1c
.RI "#define \fBlog_i\fP   \fBlog_none\fP"
.br
.ti -1c
.RI "#define \fBlog_e\fP   \fBlog_none\fP"
.br
.ti -1c
.RI "#define \fBfabs\fP   fabsf"
.br
.ti -1c
.RI "#define \fBmin\fP(a,  b)   ((a<b)?a:b)"
.br
.ti -1c
.RI "#define \fBBIT_I2C_MST_VDDIO\fP   (0x80)"
.br
.ti -1c
.RI "#define \fBBIT_FIFO_EN\fP   (0x40)"
.br
.ti -1c
.RI "#define \fBBIT_DMP_EN\fP   (0x80)"
.br
.ti -1c
.RI "#define \fBBIT_FIFO_RST\fP   (0x04)"
.br
.ti -1c
.RI "#define \fBBIT_DMP_RST\fP   (0x08)"
.br
.ti -1c
.RI "#define \fBBIT_FIFO_OVERFLOW\fP   (0x10)"
.br
.ti -1c
.RI "#define \fBBIT_DATA_RDY_EN\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBBIT_DMP_INT_EN\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBBIT_MOT_INT_EN\fP   (0x40)"
.br
.ti -1c
.RI "#define \fBBITS_FSR\fP   (0x18)"
.br
.ti -1c
.RI "#define \fBBITS_LPF\fP   (0x07)"
.br
.ti -1c
.RI "#define \fBBITS_HPF\fP   (0x07)"
.br
.ti -1c
.RI "#define \fBBITS_CLK\fP   (0x07)"
.br
.ti -1c
.RI "#define \fBBIT_FIFO_SIZE_1024\fP   (0x40)"
.br
.ti -1c
.RI "#define \fBBIT_FIFO_SIZE_2048\fP   (0x80)"
.br
.ti -1c
.RI "#define \fBBIT_FIFO_SIZE_4096\fP   (0xC0)"
.br
.ti -1c
.RI "#define \fBBIT_RESET\fP   (0x80)"
.br
.ti -1c
.RI "#define \fBBIT_SLEEP\fP   (0x40)"
.br
.ti -1c
.RI "#define \fBBIT_S0_DELAY_EN\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBBIT_S2_DELAY_EN\fP   (0x04)"
.br
.ti -1c
.RI "#define \fBBITS_SLAVE_LENGTH\fP   (0x0F)"
.br
.ti -1c
.RI "#define \fBBIT_SLAVE_BYTE_SW\fP   (0x40)"
.br
.ti -1c
.RI "#define \fBBIT_SLAVE_GROUP\fP   (0x10)"
.br
.ti -1c
.RI "#define \fBBIT_SLAVE_EN\fP   (0x80)"
.br
.ti -1c
.RI "#define \fBBIT_I2C_READ\fP   (0x80)"
.br
.ti -1c
.RI "#define \fBBITS_I2C_MASTER_DLY\fP   (0x1F)"
.br
.ti -1c
.RI "#define \fBBIT_AUX_IF_EN\fP   (0x20)"
.br
.ti -1c
.RI "#define \fBBIT_ACTL\fP   (0x80)"
.br
.ti -1c
.RI "#define \fBBIT_LATCH_EN\fP   (0x20)"
.br
.ti -1c
.RI "#define \fBBIT_ANY_RD_CLR\fP   (0x10)"
.br
.ti -1c
.RI "#define \fBBIT_BYPASS_EN\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBBITS_WOM_EN\fP   (0xC0)"
.br
.ti -1c
.RI "#define \fBBIT_LPA_CYCLE\fP   (0x20)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_XA\fP   (0x20)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_YA\fP   (0x10)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_ZA\fP   (0x08)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_XG\fP   (0x04)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_YG\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_ZG\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_XYZA\fP   (\fBBIT_STBY_XA\fP | \fBBIT_STBY_YA\fP | \fBBIT_STBY_ZA\fP)"
.br
.ti -1c
.RI "#define \fBBIT_STBY_XYZG\fP   (\fBBIT_STBY_XG\fP | \fBBIT_STBY_YG\fP | \fBBIT_STBY_ZG\fP)"
.br
.ti -1c
.RI "#define \fBMAX_PACKET_LENGTH\fP   (12)"
.br
.ti -1c
.RI "#define \fBq30\fP   1073741824\&.0f"
.br
.ti -1c
.RI "#define \fBDEFAULT_MPU_HZ\fP   (100)"
.br
.ti -1c
.RI "#define \fBINV_X_GYRO\fP   (0x40)"
.br
.ti -1c
.RI "#define \fBINV_Y_GYRO\fP   (0x20)"
.br
.ti -1c
.RI "#define \fBINV_Z_GYRO\fP   (0x10)"
.br
.ti -1c
.RI "#define \fBINV_XYZ_GYRO\fP   (\fBINV_X_GYRO\fP | \fBINV_Y_GYRO\fP | \fBINV_Z_GYRO\fP)"
.br
.ti -1c
.RI "#define \fBINV_XYZ_ACCEL\fP   (0x08)"
.br
.ti -1c
.RI "#define \fBINV_XYZ_COMPASS\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DATA_READY\fP   (0x0001)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DMP\fP   (0x0002)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_PLL_READY\fP   (0x0004)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_I2C_MST\fP   (0x0008)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_FIFO_OVERFLOW\fP   (0x0010)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_ZMOT\fP   (0x0020)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_MOT\fP   (0x0040)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_FREE_FALL\fP   (0x0080)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DMP_0\fP   (0x0100)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DMP_1\fP   (0x0200)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DMP_2\fP   (0x0400)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DMP_3\fP   (0x0800)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DMP_4\fP   (0x1000)"
.br
.ti -1c
.RI "#define \fBMPU_INT_STATUS_DMP_5\fP   (0x2000)"
.br
.ti -1c
.RI "#define \fBMOTION_DRIVER_TARGET_MSP430\fP"
.br
.ti -1c
.RI "#define \fBdelay_ms\fP   HAL_Delay"
.br
.ti -1c
.RI "#define \fBget_ms\fP   \fBmget_ms\fP"
.br
.ti -1c
.RI "#define \fBlog_i\fP   printf"
.br
.ti -1c
.RI "#define \fBlog_e\fP   printf"
.br
.ti -1c
.RI "#define \fBCFG_LP_QUAT\fP   (2712)"
.br
.ti -1c
.RI "#define \fBEND_ORIENT_TEMP\fP   (1866)"
.br
.ti -1c
.RI "#define \fBCFG_27\fP   (2742)"
.br
.ti -1c
.RI "#define \fBCFG_20\fP   (2224)"
.br
.ti -1c
.RI "#define \fBCFG_23\fP   (2745)"
.br
.ti -1c
.RI "#define \fBCFG_FIFO_ON_EVENT\fP   (2690)"
.br
.ti -1c
.RI "#define \fBEND_PREDICTION_UPDATE\fP   (1761)"
.br
.ti -1c
.RI "#define \fBCGNOTICE_INTR\fP   (2620)"
.br
.ti -1c
.RI "#define \fBX_GRT_Y_TMP\fP   (1358)"
.br
.ti -1c
.RI "#define \fBCFG_DR_INT\fP   (1029)"
.br
.ti -1c
.RI "#define \fBCFG_AUTH\fP   (1035)"
.br
.ti -1c
.RI "#define \fBUPDATE_PROP_ROT\fP   (1835)"
.br
.ti -1c
.RI "#define \fBEND_COMPARE_Y_X_TMP2\fP   (1455)"
.br
.ti -1c
.RI "#define \fBSKIP_X_GRT_Y_TMP\fP   (1359)"
.br
.ti -1c
.RI "#define \fBSKIP_END_COMPARE\fP   (1435)"
.br
.ti -1c
.RI "#define \fBFCFG_3\fP   (1088)"
.br
.ti -1c
.RI "#define \fBFCFG_2\fP   (1066)"
.br
.ti -1c
.RI "#define \fBFCFG_1\fP   (1062)"
.br
.ti -1c
.RI "#define \fBEND_COMPARE_Y_X_TMP3\fP   (1434)"
.br
.ti -1c
.RI "#define \fBFCFG_7\fP   (1073)"
.br
.ti -1c
.RI "#define \fBFCFG_6\fP   (1106)"
.br
.ti -1c
.RI "#define \fBFLAT_STATE_END\fP   (1713)"
.br
.ti -1c
.RI "#define \fBSWING_END_4\fP   (1616)"
.br
.ti -1c
.RI "#define \fBSWING_END_2\fP   (1565)"
.br
.ti -1c
.RI "#define \fBSWING_END_3\fP   (1587)"
.br
.ti -1c
.RI "#define \fBSWING_END_1\fP   (1550)"
.br
.ti -1c
.RI "#define \fBCFG_8\fP   (2718)"
.br
.ti -1c
.RI "#define \fBCFG_15\fP   (2727)"
.br
.ti -1c
.RI "#define \fBCFG_16\fP   (2746)"
.br
.ti -1c
.RI "#define \fBCFG_EXT_GYRO_BIAS\fP   (1189)"
.br
.ti -1c
.RI "#define \fBEND_COMPARE_Y_X_TMP\fP   (1407)"
.br
.ti -1c
.RI "#define \fBDO_NOT_UPDATE_PROP_ROT\fP   (1839)"
.br
.ti -1c
.RI "#define \fBCFG_7\fP   (1205)"
.br
.ti -1c
.RI "#define \fBFLAT_STATE_END_TEMP\fP   (1683)"
.br
.ti -1c
.RI "#define \fBEND_COMPARE_Y_X\fP   (1484)"
.br
.ti -1c
.RI "#define \fBSKIP_SWING_END_1\fP   (1551)"
.br
.ti -1c
.RI "#define \fBSKIP_SWING_END_3\fP   (1588)"
.br
.ti -1c
.RI "#define \fBSKIP_SWING_END_2\fP   (1566)"
.br
.ti -1c
.RI "#define \fBTILTG75_START\fP   (1672)"
.br
.ti -1c
.RI "#define \fBCFG_6\fP   (2753)"
.br
.ti -1c
.RI "#define \fBTILTL75_END\fP   (1669)"
.br
.ti -1c
.RI "#define \fBEND_ORIENT\fP   (1884)"
.br
.ti -1c
.RI "#define \fBCFG_FLICK_IN\fP   (2573)"
.br
.ti -1c
.RI "#define \fBTILTL75_START\fP   (1643)"
.br
.ti -1c
.RI "#define \fBCFG_MOTION_BIAS\fP   (1208)"
.br
.ti -1c
.RI "#define \fBX_GRT_Y\fP   (1408)"
.br
.ti -1c
.RI "#define \fBTEMPLABEL\fP   (2324)"
.br
.ti -1c
.RI "#define \fBCFG_ANDROID_ORIENT_INT\fP   (1853)"
.br
.ti -1c
.RI "#define \fBCFG_GYRO_RAW_DATA\fP   (2722)"
.br
.ti -1c
.RI "#define \fBX_GRT_Y_TMP2\fP   (1379)"
.br
.ti -1c
.RI "#define \fBD_0_22\fP   (22+512)"
.br
.ti -1c
.RI "#define \fBD_0_24\fP   (24+512)"
.br
.ti -1c
.RI "#define \fBD_0_36\fP   (36)"
.br
.ti -1c
.RI "#define \fBD_0_52\fP   (52)"
.br
.ti -1c
.RI "#define \fBD_0_96\fP   (96)"
.br
.ti -1c
.RI "#define \fBD_0_104\fP   (104)"
.br
.ti -1c
.RI "#define \fBD_0_108\fP   (108)"
.br
.ti -1c
.RI "#define \fBD_0_163\fP   (163)"
.br
.ti -1c
.RI "#define \fBD_0_188\fP   (188)"
.br
.ti -1c
.RI "#define \fBD_0_192\fP   (192)"
.br
.ti -1c
.RI "#define \fBD_0_224\fP   (224)"
.br
.ti -1c
.RI "#define \fBD_0_228\fP   (228)"
.br
.ti -1c
.RI "#define \fBD_0_232\fP   (232)"
.br
.ti -1c
.RI "#define \fBD_0_236\fP   (236)"
.br
.ti -1c
.RI "#define \fBD_1_2\fP   (256 + 2)"
.br
.ti -1c
.RI "#define \fBD_1_4\fP   (256 + 4)"
.br
.ti -1c
.RI "#define \fBD_1_8\fP   (256 + 8)"
.br
.ti -1c
.RI "#define \fBD_1_10\fP   (256 + 10)"
.br
.ti -1c
.RI "#define \fBD_1_24\fP   (256 + 24)"
.br
.ti -1c
.RI "#define \fBD_1_28\fP   (256 + 28)"
.br
.ti -1c
.RI "#define \fBD_1_36\fP   (256 + 36)"
.br
.ti -1c
.RI "#define \fBD_1_40\fP   (256 + 40)"
.br
.ti -1c
.RI "#define \fBD_1_44\fP   (256 + 44)"
.br
.ti -1c
.RI "#define \fBD_1_72\fP   (256 + 72)"
.br
.ti -1c
.RI "#define \fBD_1_74\fP   (256 + 74)"
.br
.ti -1c
.RI "#define \fBD_1_79\fP   (256 + 79)"
.br
.ti -1c
.RI "#define \fBD_1_88\fP   (256 + 88)"
.br
.ti -1c
.RI "#define \fBD_1_90\fP   (256 + 90)"
.br
.ti -1c
.RI "#define \fBD_1_92\fP   (256 + 92)"
.br
.ti -1c
.RI "#define \fBD_1_96\fP   (256 + 96)"
.br
.ti -1c
.RI "#define \fBD_1_98\fP   (256 + 98)"
.br
.ti -1c
.RI "#define \fBD_1_106\fP   (256 + 106)"
.br
.ti -1c
.RI "#define \fBD_1_108\fP   (256 + 108)"
.br
.ti -1c
.RI "#define \fBD_1_112\fP   (256 + 112)"
.br
.ti -1c
.RI "#define \fBD_1_128\fP   (256 + 144)"
.br
.ti -1c
.RI "#define \fBD_1_152\fP   (256 + 12)"
.br
.ti -1c
.RI "#define \fBD_1_160\fP   (256 + 160)"
.br
.ti -1c
.RI "#define \fBD_1_176\fP   (256 + 176)"
.br
.ti -1c
.RI "#define \fBD_1_178\fP   (256 + 178)"
.br
.ti -1c
.RI "#define \fBD_1_218\fP   (256 + 218)"
.br
.ti -1c
.RI "#define \fBD_1_232\fP   (256 + 232)"
.br
.ti -1c
.RI "#define \fBD_1_236\fP   (256 + 236)"
.br
.ti -1c
.RI "#define \fBD_1_240\fP   (256 + 240)"
.br
.ti -1c
.RI "#define \fBD_1_244\fP   (256 + 244)"
.br
.ti -1c
.RI "#define \fBD_1_250\fP   (256 + 250)"
.br
.ti -1c
.RI "#define \fBD_1_252\fP   (256 + 252)"
.br
.ti -1c
.RI "#define \fBD_2_12\fP   (512 + 12)"
.br
.ti -1c
.RI "#define \fBD_2_96\fP   (512 + 96)"
.br
.ti -1c
.RI "#define \fBD_2_108\fP   (512 + 108)"
.br
.ti -1c
.RI "#define \fBD_2_208\fP   (512 + 208)"
.br
.ti -1c
.RI "#define \fBD_2_224\fP   (512 + 224)"
.br
.ti -1c
.RI "#define \fBD_2_236\fP   (512 + 236)"
.br
.ti -1c
.RI "#define \fBD_2_244\fP   (512 + 244)"
.br
.ti -1c
.RI "#define \fBD_2_248\fP   (512 + 248)"
.br
.ti -1c
.RI "#define \fBD_2_252\fP   (512 + 252)"
.br
.ti -1c
.RI "#define \fBCPASS_BIAS_X\fP   (35 * 16 + 4)"
.br
.ti -1c
.RI "#define \fBCPASS_BIAS_Y\fP   (35 * 16 + 8)"
.br
.ti -1c
.RI "#define \fBCPASS_BIAS_Z\fP   (35 * 16 + 12)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_00\fP   (36 * 16)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_01\fP   (36 * 16 + 4)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_02\fP   (36 * 16 + 8)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_10\fP   (36 * 16 + 12)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_11\fP   (37 * 16)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_12\fP   (37 * 16 + 4)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_20\fP   (37 * 16 + 8)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_21\fP   (37 * 16 + 12)"
.br
.ti -1c
.RI "#define \fBCPASS_MTX_22\fP   (43 * 16 + 12)"
.br
.ti -1c
.RI "#define \fBD_EXT_GYRO_BIAS_X\fP   (61 * 16)"
.br
.ti -1c
.RI "#define \fBD_EXT_GYRO_BIAS_Y\fP   (61 * 16) + 4"
.br
.ti -1c
.RI "#define \fBD_EXT_GYRO_BIAS_Z\fP   (61 * 16) + 8"
.br
.ti -1c
.RI "#define \fBD_ACT0\fP   (40 * 16)"
.br
.ti -1c
.RI "#define \fBD_ACSX\fP   (40 * 16 + 4)"
.br
.ti -1c
.RI "#define \fBD_ACSY\fP   (40 * 16 + 8)"
.br
.ti -1c
.RI "#define \fBD_ACSZ\fP   (40 * 16 + 12)"
.br
.ti -1c
.RI "#define \fBFLICK_MSG\fP   (45 * 16 + 4)"
.br
.ti -1c
.RI "#define \fBFLICK_COUNTER\fP   (45 * 16 + 8)"
.br
.ti -1c
.RI "#define \fBFLICK_LOWER\fP   (45 * 16 + 12)"
.br
.ti -1c
.RI "#define \fBFLICK_UPPER\fP   (46 * 16 + 12)"
.br
.ti -1c
.RI "#define \fBD_AUTH_OUT\fP   (992)"
.br
.ti -1c
.RI "#define \fBD_AUTH_IN\fP   (996)"
.br
.ti -1c
.RI "#define \fBD_AUTH_A\fP   (1000)"
.br
.ti -1c
.RI "#define \fBD_AUTH_B\fP   (1004)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_BP_B\fP   (768 + 0x1C)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_HP_A\fP   (768 + 0x78)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_HP_B\fP   (768 + 0x7C)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_BP_A4\fP   (768 + 0x40)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_BP_A3\fP   (768 + 0x44)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_BP_A2\fP   (768 + 0x48)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_BP_A1\fP   (768 + 0x4C)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_INT_THRSH\fP   (768 + 0x68)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_CLIP\fP   (768 + 0x6C)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_SB\fP   (768 + 0x28)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_SB_TIME\fP   (768 + 0x2C)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_PEAKTHRSH\fP   (768 + 0x98)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_TIML\fP   (768 + 0x2A)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_TIMH\fP   (768 + 0x2E)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_PEAK\fP   (768 + 0X94)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_STEPCTR\fP   (768 + 0x60)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_TIMECTR\fP   (964)"
.br
.ti -1c
.RI "#define \fBD_PEDSTD_DECI\fP   (768 + 0xA0)"
.br
.ti -1c
.RI "#define \fBD_HOST_NO_MOT\fP   (976)"
.br
.ti -1c
.RI "#define \fBD_ACCEL_BIAS\fP   (660)"
.br
.ti -1c
.RI "#define \fBD_ORIENT_GAP\fP   (76)"
.br
.ti -1c
.RI "#define \fBD_TILT0_H\fP   (48)"
.br
.ti -1c
.RI "#define \fBD_TILT0_L\fP   (50)"
.br
.ti -1c
.RI "#define \fBD_TILT1_H\fP   (52)"
.br
.ti -1c
.RI "#define \fBD_TILT1_L\fP   (54)"
.br
.ti -1c
.RI "#define \fBD_TILT2_H\fP   (56)"
.br
.ti -1c
.RI "#define \fBD_TILT2_L\fP   (58)"
.br
.ti -1c
.RI "#define \fBD_TILT3_H\fP   (60)"
.br
.ti -1c
.RI "#define \fBD_TILT3_L\fP   (62)"
.br
.ti -1c
.RI "#define \fBDMP_CODE_SIZE\fP   (3062)"
.br
.ti -1c
.RI "#define \fBINT_SRC_TAP\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBINT_SRC_ANDROID_ORIENT\fP   (0x08)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_SEND_ANY_GYRO\fP"
.br
.ti -1c
.RI "#define \fBMAX_PACKET_LENGTH\fP   (32)"
.br
.ti -1c
.RI "#define \fBDMP_SAMPLE_RATE\fP   (200)"
.br
.ti -1c
.RI "#define \fBGYRO_SF\fP   (46850825LL * 200 / \fBDMP_SAMPLE_RATE\fP)"
.br
.ti -1c
.RI "#define \fBFIFO_CORRUPTION_CHECK\fP"
.br
.ti -1c
.RI "#define \fBQUAT_ERROR_THRESH\fP   (1L<<24)"
.br
.ti -1c
.RI "#define \fBQUAT_MAG_SQ_NORMALIZED\fP   (1L<<28)"
.br
.ti -1c
.RI "#define \fBQUAT_MAG_SQ_MIN\fP   (\fBQUAT_MAG_SQ_NORMALIZED\fP \- \fBQUAT_ERROR_THRESH\fP)"
.br
.ti -1c
.RI "#define \fBQUAT_MAG_SQ_MAX\fP   (\fBQUAT_MAG_SQ_NORMALIZED\fP + \fBQUAT_ERROR_THRESH\fP)"
.br
.ti -1c
.RI "#define \fBTAP_X\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBTAP_Y\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBTAP_Z\fP   (0x04)"
.br
.ti -1c
.RI "#define \fBTAP_XYZ\fP   (0x07)"
.br
.ti -1c
.RI "#define \fBTAP_X_UP\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBTAP_X_DOWN\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBTAP_Y_UP\fP   (0x03)"
.br
.ti -1c
.RI "#define \fBTAP_Y_DOWN\fP   (0x04)"
.br
.ti -1c
.RI "#define \fBTAP_Z_UP\fP   (0x05)"
.br
.ti -1c
.RI "#define \fBTAP_Z_DOWN\fP   (0x06)"
.br
.ti -1c
.RI "#define \fBANDROID_ORIENT_PORTRAIT\fP   (0x00)"
.br
.ti -1c
.RI "#define \fBANDROID_ORIENT_LANDSCAPE\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBANDROID_ORIENT_REVERSE_PORTRAIT\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBANDROID_ORIENT_REVERSE_LANDSCAPE\fP   (0x03)"
.br
.ti -1c
.RI "#define \fBDMP_INT_GESTURE\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBDMP_INT_CONTINUOUS\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_TAP\fP   (0x001)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_ANDROID_ORIENT\fP   (0x002)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_LP_QUAT\fP   (0x004)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_PEDOMETER\fP   (0x008)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_6X_LP_QUAT\fP   (0x010)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_GYRO_CAL\fP   (0x020)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_SEND_RAW_ACCEL\fP   (0x040)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_SEND_RAW_GYRO\fP   (0x080)"
.br
.ti -1c
.RI "#define \fBDMP_FEATURE_SEND_CAL_GYRO\fP   (0x100)"
.br
.ti -1c
.RI "#define \fBINV_WXYZ_QUAT\fP   (0x100)"
.br
.in -1c
.SS "枚举"

.in +1c
.ti -1c
.RI "enum \fBlpf_e\fP { \fBINV_FILTER_256HZ_NOLPF2\fP = 0, \fBINV_FILTER_188HZ\fP, \fBINV_FILTER_98HZ\fP, \fBINV_FILTER_42HZ\fP, \fBINV_FILTER_20HZ\fP, \fBINV_FILTER_10HZ\fP, \fBINV_FILTER_5HZ\fP, \fBINV_FILTER_2100HZ_NOLPF\fP, \fBNUM_FILTER\fP }"
.br
.ti -1c
.RI "enum \fBgyro_fsr_e\fP { \fBINV_FSR_250DPS\fP = 0, \fBINV_FSR_500DPS\fP, \fBINV_FSR_1000DPS\fP, \fBINV_FSR_2000DPS\fP, \fBNUM_GYRO_FSR\fP }"
.br
.ti -1c
.RI "enum \fBaccel_fsr_e\fP { \fBINV_FSR_2G\fP = 0, \fBINV_FSR_4G\fP, \fBINV_FSR_8G\fP, \fBINV_FSR_16G\fP, \fBNUM_ACCEL_FSR\fP }"
.br
.ti -1c
.RI "enum \fBclock_sel_e\fP { \fBINV_CLK_INTERNAL\fP = 0, \fBINV_CLK_PLL\fP, \fBNUM_CLK\fP }"
.br
.ti -1c
.RI "enum \fBlp_accel_rate_e\fP { \fBINV_LPA_1_25HZ\fP, \fBINV_LPA_5HZ\fP, \fBINV_LPA_20HZ\fP, \fBINV_LPA_40HZ\fP }"
.br
.in -1c
.SS "函数"

.in +1c
.ti -1c
.RI "void \fBlog_none\fP (char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "static int \fBset_int_enable\fP (unsigned char enable)"
.br
.RI "Enable/disable data ready interrupt\&. If the DMP is on, the DMP interrupt is enabled\&. Otherwise, the data ready interrupt is used\&. "
.ti -1c
.RI "int \fBmpu_reg_dump\fP (void)"
.br
.RI "Register dump for testing\&. "
.ti -1c
.RI "int \fBmpu_read_reg\fP (unsigned char \fBreg\fP, unsigned char *data)"
.br
.RI "Read from a single register\&. NOTE: The memory and FIFO read/write registers cannot be accessed\&. "
.ti -1c
.RI "int \fBmpu_init\fP (void)"
.br
.RI "Initialize hardware\&. Initial configuration:
.br
Gyro FSR: +/- 2000DPS
.br
Accel FSR +/- 2G
.br
DLPF: 42Hz
.br
FIFO rate: 50Hz
.br
Clock source: Gyro PLL
.br
FIFO: Disabled\&.
.br
Data ready interrupt: Disabled, active low, unlatched\&. "
.ti -1c
.RI "int \fBmpu_lp_accel_mode\fP (unsigned char rate)"
.br
.RI "Enter low-power accel-only mode\&. In low-power accel mode, the chip goes to sleep and only wakes up to sample the accelerometer at one of the following frequencies: 
.br
 MPU6050: 1\&.25Hz, 5Hz, 20Hz, 40Hz 
.br
 MPU6500: 1\&.25Hz, 2\&.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz 
.br
 If the requested rate is not one listed above, the device will be set to the next highest rate\&. Requesting a rate above the maximum supported frequency will result in an error\&. 
.br
 To select a fractional wake-up frequency, round down the value passed to \fIrate\fP\&. "
.ti -1c
.RI "int \fBmpu_get_gyro_reg\fP (short *data, unsigned long *timestamp)"
.br
.RI "Read raw gyro data directly from the registers\&. "
.ti -1c
.RI "int \fBmpu_get_accel_reg\fP (short *data, unsigned long *timestamp)"
.br
.RI "Read raw accel data directly from the registers\&. "
.ti -1c
.RI "int \fBmpu_get_temperature\fP (long *data, unsigned long *timestamp)"
.br
.RI "Read temperature data directly from the registers\&. "
.ti -1c
.RI "int \fBmpu_set_accel_bias\fP (const long *accel_bias)"
.br
.RI "Push biases to the accel bias registers\&. This function expects biases relative to the current sensor output, and these biases will be added to the factory-supplied values\&. "
.ti -1c
.RI "int \fBmpu_reset_fifo\fP (void)"
.br
.RI "Reset FIFO read/write pointers\&. "
.ti -1c
.RI "int \fBmpu_get_gyro_fsr\fP (unsigned short *fsr)"
.br
.RI "Get the gyro full-scale range\&. "
.ti -1c
.RI "int \fBmpu_set_gyro_fsr\fP (unsigned short fsr)"
.br
.RI "Set the gyro full-scale range\&. "
.ti -1c
.RI "int \fBmpu_get_accel_fsr\fP (unsigned char *fsr)"
.br
.RI "Get the accel full-scale range\&. "
.ti -1c
.RI "int \fBmpu_set_accel_fsr\fP (unsigned char fsr)"
.br
.RI "Set the accel full-scale range\&. "
.ti -1c
.RI "int \fBmpu_get_lpf\fP (unsigned short *lpf)"
.br
.RI "Get the current DLPF setting\&. "
.ti -1c
.RI "int \fBmpu_set_lpf\fP (unsigned short lpf)"
.br
.RI "Set digital low pass filter\&. The following LPF settings are supported: 188, 98, 42, 20, 10, 5\&. "
.ti -1c
.RI "int \fBmpu_get_sample_rate\fP (unsigned short *rate)"
.br
.RI "Get sampling rate\&. "
.ti -1c
.RI "int \fBmpu_set_sample_rate\fP (unsigned short rate)"
.br
.RI "Set sampling rate\&. Sampling rate must be between 4Hz and 1kHz\&. "
.ti -1c
.RI "int \fBmpu_get_compass_sample_rate\fP (unsigned short *rate)"
.br
.RI "Get compass sampling rate\&. "
.ti -1c
.RI "int \fBmpu_set_compass_sample_rate\fP (unsigned short rate)"
.br
.RI "Set compass sampling rate\&. The compass on the auxiliary I2C bus is read by the MPU hardware at a maximum of 100Hz\&. The actual rate can be set to a fraction of the gyro sampling rate\&. "
.ti -1c
.RI "int \fBmpu_get_gyro_sens\fP (float *sens)"
.br
.RI "Get gyro sensitivity scale factor\&. "
.ti -1c
.RI "int \fBmpu_get_accel_sens\fP (unsigned short *sens)"
.br
.RI "Get accel sensitivity scale factor\&. "
.ti -1c
.RI "int \fBmpu_get_fifo_config\fP (unsigned char *sensors)"
.br
.RI "Get current FIFO configuration\&. \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL "
.ti -1c
.RI "int \fBmpu_configure_fifo\fP (unsigned char sensors)"
.br
.RI "Select which sensors are pushed to FIFO\&. \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL "
.ti -1c
.RI "int \fBmpu_get_power_state\fP (unsigned char *power_on)"
.br
.RI "Get current power state\&. "
.ti -1c
.RI "int \fBmpu_set_sensors\fP (unsigned char sensors)"
.br
.RI "Turn specific sensors on/off\&. \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.br
 INV_XYZ_COMPASS "
.ti -1c
.RI "int \fBmpu_get_int_status\fP (short *status)"
.br
.RI "Read the MPU interrupt status registers\&. "
.ti -1c
.RI "int \fBmpu_read_fifo\fP (short *gyro, short *accel, unsigned long *timestamp, unsigned char *sensors, unsigned char *more)"
.br
.RI "Get one packet from the FIFO\&. If \fIsensors\fP does not contain a particular sensor, disregard the data returned to that pointer\&. 
.br
 \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.br
 If the FIFO has no new data, \fIsensors\fP will be zero\&. 
.br
 If the FIFO is disabled, \fIsensors\fP will be zero and this function will return a non-zero error code\&. "
.ti -1c
.RI "int \fBmpu_read_fifo_stream\fP (unsigned short length, unsigned char *data, unsigned char *more)"
.br
.RI "Get one unparsed packet from the FIFO\&. This function should be used if the packet is to be parsed elsewhere\&. "
.ti -1c
.RI "int \fBmpu_set_bypass\fP (unsigned char bypass_on)"
.br
.RI "Set device to bypass mode\&. "
.ti -1c
.RI "int \fBmpu_set_int_level\fP (unsigned char active_low)"
.br
.RI "Set interrupt level\&. "
.ti -1c
.RI "int \fBmpu_set_int_latched\fP (unsigned char enable)"
.br
.RI "Enable latched interrupts\&. Any MPU register will clear the interrupt\&. "
.ti -1c
.RI "static int \fBget_accel_prod_shift\fP (float *st_shift)"
.br
.ti -1c
.RI "static int \fBaccel_self_test\fP (long *bias_regular, long *bias_st)"
.br
.ti -1c
.RI "static int \fBgyro_self_test\fP (long *bias_regular, long *bias_st)"
.br
.ti -1c
.RI "static int \fBget_st_biases\fP (long *gyro, long *accel, unsigned char hw_test)"
.br
.ti -1c
.RI "int \fBmpu_run_self_test\fP (long *gyro, long *accel)"
.br
.RI "Trigger gyro/accel/compass self-test\&. On success/error, the self-test returns a mask representing the sensor(s) that failed\&. For each bit, a one (1) represents a 'pass' case; conversely, a zero (0) indicates a failure\&. "
.ti -1c
.RI "int \fBmpu_write_mem\fP (unsigned short mem_addr, unsigned short length, unsigned char *data)"
.br
.RI "Write to the DMP memory\&. This function prevents I2C writes past the bank boundaries\&. The DMP memory is only accessible when the chip is awake\&. "
.ti -1c
.RI "int \fBmpu_read_mem\fP (unsigned short mem_addr, unsigned short length, unsigned char *data)"
.br
.RI "Read from the DMP memory\&. This function prevents I2C reads past the bank boundaries\&. The DMP memory is only accessible when the chip is awake\&. "
.ti -1c
.RI "int \fBmpu_load_firmware\fP (unsigned short length, const unsigned char *firmware, unsigned short start_addr, unsigned short sample_rate)"
.br
.RI "Load and verify DMP image\&. "
.ti -1c
.RI "int \fBmpu_set_dmp_state\fP (unsigned char enable)"
.br
.RI "Enable/disable DMP support\&. "
.ti -1c
.RI "int \fBmpu_get_dmp_state\fP (unsigned char *enabled)"
.br
.RI "Get DMP state\&. "
.ti -1c
.RI "int \fBsetup_compass\fP (void)"
.br
.ti -1c
.RI "int \fBmpu_get_compass_reg\fP (short *data, unsigned long *timestamp)"
.br
.RI "Read raw compass data\&. "
.ti -1c
.RI "int \fBmpu_get_compass_fsr\fP (unsigned short *fsr)"
.br
.RI "Get the compass full-scale range\&. "
.ti -1c
.RI "int \fBmpu_lp_motion_interrupt\fP (unsigned short thresh, unsigned char time, unsigned char lpa_freq)"
.br
.RI "Enters LP accel motion interrupt mode\&. The behavior of this feature is very different between the MPU6050 and the MPU6500\&. Each chip's version of this feature is explained below\&. "
.ti -1c
.RI "\fBu8\fP \fBrun_self_test\fP (void)"
.br
.ti -1c
.RI "unsigned short \fBinv_orientation_matrix_to_scalar\fP (const signed char *mtx)"
.br
.ti -1c
.RI "unsigned short \fBinv_row_2_scale\fP (const signed char *row)"
.br
.ti -1c
.RI "void \fBmget_ms\fP (unsigned long *time)"
.br
.ti -1c
.RI "\fBu8\fP \fBmpu_dmp_init\fP (void)"
.br
.ti -1c
.RI "\fBu8\fP \fBmpu_dmp_get_data\fP (float *pitch, float *roll, float *yaw)"
.br
.ti -1c
.RI "int \fBmpu_init_slave\fP (void)"
.br
.ti -1c
.RI "int \fBmpu_register_tap_cb\fP (void(*func)(unsigned char, unsigned char))"
.br
.ti -1c
.RI "int \fBdmp_load_motion_driver_firmware\fP (void)"
.br
.RI "Load the DMP with this image\&. "
.ti -1c
.RI "int \fBdmp_set_orientation\fP (unsigned short orient)"
.br
.RI "Push gyro and accel orientation to the DMP\&. The orientation is represented here as the output of \fIinv_orientation_matrix_to_scalar\fP\&. "
.ti -1c
.RI "int \fBdmp_set_gyro_bias\fP (long *bias)"
.br
.RI "Push gyro biases to the DMP\&. Because the gyro integration is handled in the DMP, any gyro biases calculated by the MPL should be pushed down to DMP memory to remove 3-axis quaternion drift\&. 
.br
 NOTE: If the DMP-based gyro calibration is enabled, the DMP will overwrite the biases written to this location once a new one is computed\&. "
.ti -1c
.RI "int \fBdmp_set_accel_bias\fP (long *bias)"
.br
.RI "Push accel biases to the DMP\&. These biases will be removed from the DMP 6-axis quaternion\&. "
.ti -1c
.RI "int \fBdmp_set_fifo_rate\fP (unsigned short rate)"
.br
.RI "Set DMP output rate\&. Only used when DMP is on\&. "
.ti -1c
.RI "int \fBdmp_get_fifo_rate\fP (unsigned short *rate)"
.br
.RI "Get DMP output rate\&. "
.ti -1c
.RI "int \fBdmp_set_tap_thresh\fP (unsigned char axis, unsigned short thresh)"
.br
.RI "Set tap threshold for a specific axis\&. "
.ti -1c
.RI "int \fBdmp_set_tap_axes\fP (unsigned char axis)"
.br
.RI "Set which axes will register a tap\&. "
.ti -1c
.RI "int \fBdmp_set_tap_count\fP (unsigned char min_taps)"
.br
.RI "Set minimum number of taps needed for an interrupt\&. "
.ti -1c
.RI "int \fBdmp_set_tap_time\fP (unsigned short time)"
.br
.RI "Set length between valid taps\&. "
.ti -1c
.RI "int \fBdmp_set_tap_time_multi\fP (unsigned short time)"
.br
.RI "Set max time between taps to register as a multi-tap\&. "
.ti -1c
.RI "int \fBdmp_set_shake_reject_thresh\fP (long sf, unsigned short thresh)"
.br
.RI "Set shake rejection threshold\&. If the DMP detects a gyro sample larger than \fIthresh\fP, taps are rejected\&. "
.ti -1c
.RI "int \fBdmp_set_shake_reject_time\fP (unsigned short time)"
.br
.RI "Set shake rejection time\&. Sets the length of time that the gyro must be outside of the threshold set by \fIgyro_set_shake_reject_thresh\fP before taps are rejected\&. A mandatory 60 ms is added to this parameter\&. "
.ti -1c
.RI "int \fBdmp_set_shake_reject_timeout\fP (unsigned short time)"
.br
.RI "Set shake rejection timeout\&. Sets the length of time after a shake rejection that the gyro must stay inside of the threshold before taps can be detected again\&. A mandatory 60 ms is added to this parameter\&. "
.ti -1c
.RI "int \fBdmp_get_pedometer_step_count\fP (unsigned long *count)"
.br
.RI "Get current step count\&. "
.ti -1c
.RI "int \fBdmp_set_pedometer_step_count\fP (unsigned long count)"
.br
.RI "Overwrite current step count\&. WARNING: This function writes to DMP memory and could potentially encounter a race condition if called while the pedometer is enabled\&. "
.ti -1c
.RI "int \fBdmp_get_pedometer_walk_time\fP (unsigned long *time)"
.br
.RI "Get duration of walking time\&. "
.ti -1c
.RI "int \fBdmp_set_pedometer_walk_time\fP (unsigned long time)"
.br
.RI "Overwrite current walk time\&. WARNING: This function writes to DMP memory and could potentially encounter a race condition if called while the pedometer is enabled\&. "
.ti -1c
.RI "int \fBdmp_enable_feature\fP (unsigned short mask)"
.br
.RI "Enable DMP features\&. The following #define's are used in the input mask: 
.br
 DMP_FEATURE_TAP 
.br
 DMP_FEATURE_ANDROID_ORIENT 
.br
 DMP_FEATURE_LP_QUAT 
.br
 DMP_FEATURE_6X_LP_QUAT 
.br
 DMP_FEATURE_GYRO_CAL 
.br
 DMP_FEATURE_SEND_RAW_ACCEL 
.br
 DMP_FEATURE_SEND_RAW_GYRO 
.br
 NOTE: DMP_FEATURE_LP_QUAT and DMP_FEATURE_6X_LP_QUAT are mutually exclusive\&. 
.br
 NOTE: DMP_FEATURE_SEND_RAW_GYRO and DMP_FEATURE_SEND_CAL_GYRO are also mutually exclusive\&. "
.ti -1c
.RI "int \fBdmp_get_enabled_features\fP (unsigned short *mask)"
.br
.RI "Get list of currently enabled DMP features\&. "
.ti -1c
.RI "int \fBdmp_enable_gyro_cal\fP (unsigned char enable)"
.br
.RI "Calibrate the gyro data in the DMP\&. After eight seconds of no motion, the DMP will compute gyro biases and subtract them from the quaternion output\&. If \fIdmp_enable_feature\fP is called with \fIDMP_FEATURE_SEND_CAL_GYRO\fP, the biases will also be subtracted from the gyro output\&. "
.ti -1c
.RI "int \fBdmp_enable_lp_quat\fP (unsigned char enable)"
.br
.RI "Generate 3-axis quaternions from the DMP\&. In this driver, the 3-axis and 6-axis DMP quaternion features are mutually exclusive\&. "
.ti -1c
.RI "int \fBdmp_enable_6x_lp_quat\fP (unsigned char enable)"
.br
.RI "Generate 6-axis quaternions from the DMP\&. In this driver, the 3-axis and 6-axis DMP quaternion features are mutually exclusive\&. "
.ti -1c
.RI "static int \fBdecode_gesture\fP (unsigned char *gesture)"
.br
.RI "Decode the four-byte gesture data and execute any callbacks\&. "
.ti -1c
.RI "int \fBdmp_set_interrupt_mode\fP (unsigned char mode)"
.br
.RI "Specify when a DMP interrupt should occur\&. A DMP interrupt can be configured to trigger on either of the two conditions below: 
.br
 a\&. One FIFO period has elapsed (set by \fImpu_set_sample_rate\fP)\&. 
.br
 b\&. A tap event has been detected\&. "
.ti -1c
.RI "int \fBdmp_read_fifo\fP (short *gyro, short *accel, long *quat, unsigned long *timestamp, short *sensors, unsigned char *more)"
.br
.RI "Get one packet from the FIFO\&. If \fIsensors\fP does not contain a particular sensor, disregard the data returned to that pointer\&. 
.br
 \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.br
 INV_WXYZ_QUAT 
.br
 If the FIFO has no new data, \fIsensors\fP will be zero\&. 
.br
 If the FIFO is disabled, \fIsensors\fP will be zero and this function will return a non-zero error code\&. "
.ti -1c
.RI "int \fBdmp_register_tap_cb\fP (void(*func)(unsigned char, unsigned char))"
.br
.RI "Register a function to be executed on a tap event\&. The tap direction is represented by one of the following: 
.br
 TAP_X_UP 
.br
 TAP_X_DOWN 
.br
 TAP_Y_UP 
.br
 TAP_Y_DOWN 
.br
 TAP_Z_UP 
.br
 TAP_Z_DOWN "
.ti -1c
.RI "int \fBdmp_register_android_orient_cb\fP (void(*func)(unsigned char))"
.br
.RI "Register a function to be executed on a android orientation event\&. "
.in -1c
.SS "变量"

.in +1c
.ti -1c
.RI "unsigned char \fBgyro_reg_s::who_am_i\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::rate_div\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::lpf\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::prod_id\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::user_ctrl\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::fifo_en\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::gyro_cfg\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::accel_cfg\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::motion_thr\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::motion_dur\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::fifo_count_h\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::fifo_r_w\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::raw_gyro\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::raw_accel\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::temp\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::int_enable\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::dmp_int_status\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::int_status\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::pwr_mgmt_1\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::pwr_mgmt_2\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::int_pin_cfg\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::mem_r_w\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::accel_offs\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::i2c_mst\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::bank_sel\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::mem_start_addr\fP"
.br
.ti -1c
.RI "unsigned char \fBgyro_reg_s::prgm_start_h\fP"
.br
.ti -1c
.RI "unsigned char \fBhw_s::addr\fP"
.br
.ti -1c
.RI "unsigned short \fBhw_s::max_fifo\fP"
.br
.ti -1c
.RI "unsigned char \fBhw_s::num_reg\fP"
.br
.ti -1c
.RI "unsigned short \fBhw_s::temp_sens\fP"
.br
.ti -1c
.RI "short \fBhw_s::temp_offset\fP"
.br
.ti -1c
.RI "unsigned short \fBhw_s::bank_size\fP"
.br
.ti -1c
.RI "unsigned short \fBmotion_int_cache_s::gyro_fsr\fP"
.br
.ti -1c
.RI "unsigned char \fBmotion_int_cache_s::accel_fsr\fP"
.br
.ti -1c
.RI "unsigned short \fBmotion_int_cache_s::lpf\fP"
.br
.ti -1c
.RI "unsigned short \fBmotion_int_cache_s::sample_rate\fP"
.br
.ti -1c
.RI "unsigned char \fBmotion_int_cache_s::sensors_on\fP"
.br
.ti -1c
.RI "unsigned char \fBmotion_int_cache_s::fifo_sensors\fP"
.br
.ti -1c
.RI "unsigned char \fBmotion_int_cache_s::dmp_on\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::gyro_fsr\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::accel_fsr\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::sensors\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::lpf\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::clk_src\fP"
.br
.ti -1c
.RI "unsigned short \fBchip_cfg_s::sample_rate\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::fifo_enable\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::int_enable\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::bypass_mode\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::accel_half\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::lp_accel_mode\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::int_motion_only\fP"
.br
.ti -1c
.RI "struct \fBmotion_int_cache_s\fP \fBchip_cfg_s::cache\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::active_low_int\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::latched_int\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::dmp_on\fP"
.br
.ti -1c
.RI "unsigned char \fBchip_cfg_s::dmp_loaded\fP"
.br
.ti -1c
.RI "unsigned short \fBchip_cfg_s::dmp_sample_rate\fP"
.br
.ti -1c
.RI "unsigned long \fBtest_s::gyro_sens\fP"
.br
.ti -1c
.RI "unsigned long \fBtest_s::accel_sens\fP"
.br
.ti -1c
.RI "unsigned char \fBtest_s::reg_rate_div\fP"
.br
.ti -1c
.RI "unsigned char \fBtest_s::reg_lpf\fP"
.br
.ti -1c
.RI "unsigned char \fBtest_s::reg_gyro_fsr\fP"
.br
.ti -1c
.RI "unsigned char \fBtest_s::reg_accel_fsr\fP"
.br
.ti -1c
.RI "unsigned short \fBtest_s::wait_ms\fP"
.br
.ti -1c
.RI "unsigned char \fBtest_s::packet_thresh\fP"
.br
.ti -1c
.RI "float \fBtest_s::min_dps\fP"
.br
.ti -1c
.RI "float \fBtest_s::max_dps\fP"
.br
.ti -1c
.RI "float \fBtest_s::max_gyro_var\fP"
.br
.ti -1c
.RI "float \fBtest_s::min_g\fP"
.br
.ti -1c
.RI "float \fBtest_s::max_g\fP"
.br
.ti -1c
.RI "float \fBtest_s::max_accel_var\fP"
.br
.ti -1c
.RI "const struct \fBgyro_reg_s\fP * \fBgyro_state_s::reg\fP"
.br
.ti -1c
.RI "const struct \fBhw_s\fP * \fBgyro_state_s::hw\fP"
.br
.ti -1c
.RI "struct \fBchip_cfg_s\fP \fBgyro_state_s::chip_cfg\fP"
.br
.ti -1c
.RI "const struct \fBtest_s\fP * \fBgyro_state_s::test\fP"
.br
.ti -1c
.RI "const struct \fBgyro_reg_s\fP \fBreg\fP"
.br
.ti -1c
.RI "const struct \fBhw_s\fP \fBhw\fP"
.br
.ti -1c
.RI "const struct \fBtest_s\fP \fBtest\fP"
.br
.ti -1c
.RI "static struct \fBgyro_state_s\fP \fBst\fP"
.br
.ti -1c
.RI "static signed char \fBgyro_orientation\fP [9]"
.br
.ti -1c
.RI "void(* \fBint_param_s::cb\fP )(void)"
.br
.ti -1c
.RI "unsigned short \fBint_param_s::pin\fP"
.br
.ti -1c
.RI "unsigned char \fBint_param_s::lp_exit\fP"
.br
.ti -1c
.RI "unsigned char \fBint_param_s::active_low\fP"
.br
.ti -1c
.RI "static const unsigned char \fBdmp_memory\fP [\fBDMP_CODE_SIZE\fP]"
.br
.ti -1c
.RI "static const unsigned short \fBsStartAddress\fP = 0x0400"
.br
.ti -1c
.RI "static struct \fBdmp_s\fP \fBdmp\fP"
.br
.in -1c
.SH "详细描述"
.PP 
Hardware drivers to communicate with sensors via I2C\&. 


.SH "宏定义说明"
.PP 
.SS "#define ANDROID_ORIENT_LANDSCAPE   (0x01)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB33\fP 行定义\&.
.SS "#define ANDROID_ORIENT_PORTRAIT   (0x00)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB32\fP 行定义\&.
.SS "#define ANDROID_ORIENT_REVERSE_LANDSCAPE   (0x03)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB35\fP 行定义\&.
.SS "#define ANDROID_ORIENT_REVERSE_PORTRAIT   (0x02)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB34\fP 行定义\&.
.SS "#define BIT_ACTL   (0x80)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB394\fP 行定义\&.
.SS "#define BIT_ANY_RD_CLR   (0x10)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB396\fP 行定义\&.
.SS "#define BIT_AUX_IF_EN   (0x20)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB393\fP 行定义\&.
.SS "#define BIT_BYPASS_EN   (0x02)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB397\fP 行定义\&.
.SS "#define BIT_DATA_RDY_EN   (0x01)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB373\fP 行定义\&.
.SS "#define BIT_DMP_EN   (0x80)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB369\fP 行定义\&.
.SS "#define BIT_DMP_INT_EN   (0x02)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB374\fP 行定义\&.
.SS "#define BIT_DMP_RST   (0x08)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB371\fP 行定义\&.
.SS "#define BIT_FIFO_EN   (0x40)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB368\fP 行定义\&.
.SS "#define BIT_FIFO_OVERFLOW   (0x10)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB372\fP 行定义\&.
.SS "#define BIT_FIFO_RST   (0x04)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB370\fP 行定义\&.
.SS "#define BIT_FIFO_SIZE_1024   (0x40)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB380\fP 行定义\&.
.SS "#define BIT_FIFO_SIZE_2048   (0x80)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB381\fP 行定义\&.
.SS "#define BIT_FIFO_SIZE_4096   (0xC0)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB382\fP 行定义\&.
.SS "#define BIT_I2C_MST_VDDIO   (0x80)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB367\fP 行定义\&.
.SS "#define BIT_I2C_READ   (0x80)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB391\fP 行定义\&.
.SS "#define BIT_LATCH_EN   (0x20)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB395\fP 行定义\&.
.SS "#define BIT_LPA_CYCLE   (0x20)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB399\fP 行定义\&.
.SS "#define BIT_MOT_INT_EN   (0x40)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB375\fP 行定义\&.
.SS "#define BIT_RESET   (0x80)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB383\fP 行定义\&.
.SS "#define BIT_S0_DELAY_EN   (0x01)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB385\fP 行定义\&.
.SS "#define BIT_S2_DELAY_EN   (0x04)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB386\fP 行定义\&.
.SS "#define BIT_SLAVE_BYTE_SW   (0x40)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB388\fP 行定义\&.
.SS "#define BIT_SLAVE_EN   (0x80)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB390\fP 行定义\&.
.SS "#define BIT_SLAVE_GROUP   (0x10)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB389\fP 行定义\&.
.SS "#define BIT_SLEEP   (0x40)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB384\fP 行定义\&.
.SS "#define BIT_STBY_XA   (0x20)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB400\fP 行定义\&.
.SS "#define BIT_STBY_XG   (0x04)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB403\fP 行定义\&.
.SS "#define BIT_STBY_XYZA   (\fBBIT_STBY_XA\fP | \fBBIT_STBY_YA\fP | \fBBIT_STBY_ZA\fP)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB406\fP 行定义\&.
.SS "#define BIT_STBY_XYZG   (\fBBIT_STBY_XG\fP | \fBBIT_STBY_YG\fP | \fBBIT_STBY_ZG\fP)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB407\fP 行定义\&.
.SS "#define BIT_STBY_YA   (0x10)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB401\fP 行定义\&.
.SS "#define BIT_STBY_YG   (0x02)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB404\fP 行定义\&.
.SS "#define BIT_STBY_ZA   (0x08)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB402\fP 行定义\&.
.SS "#define BIT_STBY_ZG   (0x01)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB405\fP 行定义\&.
.SS "#define BITS_CLK   (0x07)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB379\fP 行定义\&.
.SS "#define BITS_FSR   (0x18)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB376\fP 行定义\&.
.SS "#define BITS_HPF   (0x07)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB378\fP 行定义\&.
.SS "#define BITS_I2C_MASTER_DLY   (0x1F)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB392\fP 行定义\&.
.SS "#define BITS_LPF   (0x07)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB377\fP 行定义\&.
.SS "#define BITS_SLAVE_LENGTH   (0x0F)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB387\fP 行定义\&.
.SS "#define BITS_WOM_EN   (0xC0)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB398\fP 行定义\&.
.SS "#define CFG_15   (2727)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB103\fP 行定义\&.
.SS "#define CFG_16   (2746)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB104\fP 行定义\&.
.SS "#define CFG_20   (2224)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB79\fP 行定义\&.
.SS "#define CFG_23   (2745)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB80\fP 行定义\&.
.SS "#define CFG_27   (2742)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB78\fP 行定义\&.
.SS "#define CFG_6   (2753)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB115\fP 行定义\&.
.SS "#define CFG_7   (1205)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB108\fP 行定义\&.
.SS "#define CFG_8   (2718)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB102\fP 行定义\&.
.SS "#define CFG_ANDROID_ORIENT_INT   (1853)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB123\fP 行定义\&.
.SS "#define CFG_AUTH   (1035)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB86\fP 行定义\&.
.SS "#define CFG_DR_INT   (1029)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB85\fP 行定义\&.
.SS "#define CFG_EXT_GYRO_BIAS   (1189)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB105\fP 行定义\&.
.SS "#define CFG_FIFO_ON_EVENT   (2690)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB81\fP 行定义\&.
.SS "#define CFG_FLICK_IN   (2573)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB118\fP 行定义\&.
.SS "#define CFG_GYRO_RAW_DATA   (2722)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB124\fP 行定义\&.
.SS "#define CFG_LP_QUAT   (2712)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB76\fP 行定义\&.
.SS "#define CFG_MOTION_BIAS   (1208)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB120\fP 行定义\&.
.SS "#define CGNOTICE_INTR   (2620)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB83\fP 行定义\&.
.SS "#define CPASS_BIAS_X   (35 * 16 + 4)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB185\fP 行定义\&.
.SS "#define CPASS_BIAS_Y   (35 * 16 + 8)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB186\fP 行定义\&.
.SS "#define CPASS_BIAS_Z   (35 * 16 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB187\fP 行定义\&.
.SS "#define CPASS_MTX_00   (36 * 16)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB188\fP 行定义\&.
.SS "#define CPASS_MTX_01   (36 * 16 + 4)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB189\fP 行定义\&.
.SS "#define CPASS_MTX_02   (36 * 16 + 8)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB190\fP 行定义\&.
.SS "#define CPASS_MTX_10   (36 * 16 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB191\fP 行定义\&.
.SS "#define CPASS_MTX_11   (37 * 16)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB192\fP 行定义\&.
.SS "#define CPASS_MTX_12   (37 * 16 + 4)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB193\fP 行定义\&.
.SS "#define CPASS_MTX_20   (37 * 16 + 8)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB194\fP 行定义\&.
.SS "#define CPASS_MTX_21   (37 * 16 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB195\fP 行定义\&.
.SS "#define CPASS_MTX_22   (43 * 16 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB196\fP 行定义\&.
.SS "#define D_0_104   (104)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB133\fP 行定义\&.
.SS "#define D_0_108   (108)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB134\fP 行定义\&.
.SS "#define D_0_163   (163)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB135\fP 行定义\&.
.SS "#define D_0_188   (188)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB136\fP 行定义\&.
.SS "#define D_0_192   (192)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB137\fP 行定义\&.
.SS "#define D_0_22   (22+512)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB127\fP 行定义\&.
.SS "#define D_0_224   (224)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB138\fP 行定义\&.
.SS "#define D_0_228   (228)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB139\fP 行定义\&.
.SS "#define D_0_232   (232)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB140\fP 行定义\&.
.SS "#define D_0_236   (236)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB141\fP 行定义\&.
.SS "#define D_0_24   (24+512)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB128\fP 行定义\&.
.SS "#define D_0_36   (36)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB130\fP 行定义\&.
.SS "#define D_0_52   (52)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB131\fP 行定义\&.
.SS "#define D_0_96   (96)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB132\fP 行定义\&.
.SS "#define D_1_10   (256 + 10)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB146\fP 行定义\&.
.SS "#define D_1_106   (256 + 106)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB160\fP 行定义\&.
.SS "#define D_1_108   (256 + 108)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB161\fP 行定义\&.
.SS "#define D_1_112   (256 + 112)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB162\fP 行定义\&.
.SS "#define D_1_128   (256 + 144)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB163\fP 行定义\&.
.SS "#define D_1_152   (256 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB164\fP 行定义\&.
.SS "#define D_1_160   (256 + 160)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB165\fP 行定义\&.
.SS "#define D_1_176   (256 + 176)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB166\fP 行定义\&.
.SS "#define D_1_178   (256 + 178)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB167\fP 行定义\&.
.SS "#define D_1_2   (256 + 2)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB143\fP 行定义\&.
.SS "#define D_1_218   (256 + 218)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB168\fP 行定义\&.
.SS "#define D_1_232   (256 + 232)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB169\fP 行定义\&.
.SS "#define D_1_236   (256 + 236)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB170\fP 行定义\&.
.SS "#define D_1_24   (256 + 24)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB147\fP 行定义\&.
.SS "#define D_1_240   (256 + 240)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB171\fP 行定义\&.
.SS "#define D_1_244   (256 + 244)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB172\fP 行定义\&.
.SS "#define D_1_250   (256 + 250)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB173\fP 行定义\&.
.SS "#define D_1_252   (256 + 252)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB174\fP 行定义\&.
.SS "#define D_1_28   (256 + 28)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB148\fP 行定义\&.
.SS "#define D_1_36   (256 + 36)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB149\fP 行定义\&.
.SS "#define D_1_4   (256 + 4)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB144\fP 行定义\&.
.SS "#define D_1_40   (256 + 40)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB150\fP 行定义\&.
.SS "#define D_1_44   (256 + 44)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB151\fP 行定义\&.
.SS "#define D_1_72   (256 + 72)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB152\fP 行定义\&.
.SS "#define D_1_74   (256 + 74)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB153\fP 行定义\&.
.SS "#define D_1_79   (256 + 79)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB154\fP 行定义\&.
.SS "#define D_1_8   (256 + 8)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB145\fP 行定义\&.
.SS "#define D_1_88   (256 + 88)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB155\fP 行定义\&.
.SS "#define D_1_90   (256 + 90)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB156\fP 行定义\&.
.SS "#define D_1_92   (256 + 92)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB157\fP 行定义\&.
.SS "#define D_1_96   (256 + 96)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB158\fP 行定义\&.
.SS "#define D_1_98   (256 + 98)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB159\fP 行定义\&.
.SS "#define D_2_108   (512 + 108)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB177\fP 行定义\&.
.SS "#define D_2_12   (512 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB175\fP 行定义\&.
.SS "#define D_2_208   (512 + 208)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB178\fP 行定义\&.
.SS "#define D_2_224   (512 + 224)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB179\fP 行定义\&.
.SS "#define D_2_236   (512 + 236)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB180\fP 行定义\&.
.SS "#define D_2_244   (512 + 244)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB181\fP 行定义\&.
.SS "#define D_2_248   (512 + 248)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB182\fP 行定义\&.
.SS "#define D_2_252   (512 + 252)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB183\fP 行定义\&.
.SS "#define D_2_96   (512 + 96)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB176\fP 行定义\&.
.SS "#define D_ACCEL_BIAS   (660)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB235\fP 行定义\&.
.SS "#define D_ACSX   (40 * 16 + 4)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB201\fP 行定义\&.
.SS "#define D_ACSY   (40 * 16 + 8)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB202\fP 行定义\&.
.SS "#define D_ACSZ   (40 * 16 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB203\fP 行定义\&.
.SS "#define D_ACT0   (40 * 16)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB200\fP 行定义\&.
.SS "#define D_AUTH_A   (1000)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB212\fP 行定义\&.
.SS "#define D_AUTH_B   (1004)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB213\fP 行定义\&.
.SS "#define D_AUTH_IN   (996)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB211\fP 行定义\&.
.SS "#define D_AUTH_OUT   (992)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB210\fP 行定义\&.
.SS "#define D_EXT_GYRO_BIAS_X   (61 * 16)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB197\fP 行定义\&.
.SS "#define D_EXT_GYRO_BIAS_Y   (61 * 16) + 4"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB198\fP 行定义\&.
.SS "#define D_EXT_GYRO_BIAS_Z   (61 * 16) + 8"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB199\fP 行定义\&.
.SS "#define D_HOST_NO_MOT   (976)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB234\fP 行定义\&.
.SS "#define D_ORIENT_GAP   (76)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB237\fP 行定义\&.
.SS "#define D_PEDSTD_BP_A1   (768 + 0x4C)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB221\fP 行定义\&.
.SS "#define D_PEDSTD_BP_A2   (768 + 0x48)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB220\fP 行定义\&.
.SS "#define D_PEDSTD_BP_A3   (768 + 0x44)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB219\fP 行定义\&.
.SS "#define D_PEDSTD_BP_A4   (768 + 0x40)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB218\fP 行定义\&.
.SS "#define D_PEDSTD_BP_B   (768 + 0x1C)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB215\fP 行定义\&.
.SS "#define D_PEDSTD_CLIP   (768 + 0x6C)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB223\fP 行定义\&.
.SS "#define D_PEDSTD_DECI   (768 + 0xA0)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB232\fP 行定义\&.
.SS "#define D_PEDSTD_HP_A   (768 + 0x78)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB216\fP 行定义\&.
.SS "#define D_PEDSTD_HP_B   (768 + 0x7C)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB217\fP 行定义\&.
.SS "#define D_PEDSTD_INT_THRSH   (768 + 0x68)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB222\fP 行定义\&.
.SS "#define D_PEDSTD_PEAK   (768 + 0X94)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB229\fP 行定义\&.
.SS "#define D_PEDSTD_PEAKTHRSH   (768 + 0x98)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB226\fP 行定义\&.
.SS "#define D_PEDSTD_SB   (768 + 0x28)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB224\fP 行定义\&.
.SS "#define D_PEDSTD_SB_TIME   (768 + 0x2C)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB225\fP 行定义\&.
.SS "#define D_PEDSTD_STEPCTR   (768 + 0x60)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB230\fP 行定义\&.
.SS "#define D_PEDSTD_TIMECTR   (964)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB231\fP 行定义\&.
.SS "#define D_PEDSTD_TIMH   (768 + 0x2E)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB228\fP 行定义\&.
.SS "#define D_PEDSTD_TIML   (768 + 0x2A)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB227\fP 行定义\&.
.SS "#define D_TILT0_H   (48)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB239\fP 行定义\&.
.SS "#define D_TILT0_L   (50)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB240\fP 行定义\&.
.SS "#define D_TILT1_H   (52)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB241\fP 行定义\&.
.SS "#define D_TILT1_L   (54)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB242\fP 行定义\&.
.SS "#define D_TILT2_H   (56)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB243\fP 行定义\&.
.SS "#define D_TILT2_L   (58)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB244\fP 行定义\&.
.SS "#define D_TILT3_H   (60)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB245\fP 行定义\&.
.SS "#define D_TILT3_L   (62)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB246\fP 行定义\&.
.SS "#define DEFAULT_MPU_HZ   (100)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB27\fP 行定义\&.
.SS "#define delay_ms   HAL_Delay"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB49\fP 行定义\&.
.SS "#define delay_ms   HAL_Delay"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB41\fP 行定义\&.
.SS "#define DMP_CODE_SIZE   (3062)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB248\fP 行定义\&.
.SS "#define DMP_FEATURE_6X_LP_QUAT   (0x010)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB44\fP 行定义\&.
.SS "#define DMP_FEATURE_ANDROID_ORIENT   (0x002)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB41\fP 行定义\&.
.SS "#define DMP_FEATURE_GYRO_CAL   (0x020)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB45\fP 行定义\&.
.SS "#define DMP_FEATURE_LP_QUAT   (0x004)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB42\fP 行定义\&.
.SS "#define DMP_FEATURE_PEDOMETER   (0x008)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB43\fP 行定义\&.
.SS "#define DMP_FEATURE_SEND_ANY_GYRO"
\fB值:\fP
.PP
.nf
                                     (DMP_FEATURE_SEND_RAW_GYRO | \
                                     DMP_FEATURE_SEND_CAL_GYRO)
.fi
.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB465\fP 行定义\&.
.SS "#define DMP_FEATURE_SEND_CAL_GYRO   (0x100)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB48\fP 行定义\&.
.SS "#define DMP_FEATURE_SEND_RAW_ACCEL   (0x040)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB46\fP 行定义\&.
.SS "#define DMP_FEATURE_SEND_RAW_GYRO   (0x080)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB47\fP 行定义\&.
.SS "#define DMP_FEATURE_TAP   (0x001)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB40\fP 行定义\&.
.SS "#define DMP_INT_CONTINUOUS   (0x02)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB38\fP 行定义\&.
.SS "#define DMP_INT_GESTURE   (0x01)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB37\fP 行定义\&.
.SS "#define DMP_SAMPLE_RATE   (200)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB470\fP 行定义\&.
.SS "#define DO_NOT_UPDATE_PROP_ROT   (1839)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB107\fP 行定义\&.
.SS "#define END_COMPARE_Y_X   (1484)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB110\fP 行定义\&.
.SS "#define END_COMPARE_Y_X_TMP   (1407)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB106\fP 行定义\&.
.SS "#define END_COMPARE_Y_X_TMP2   (1455)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB88\fP 行定义\&.
.SS "#define END_COMPARE_Y_X_TMP3   (1434)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB94\fP 行定义\&.
.SS "#define END_ORIENT   (1884)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB117\fP 行定义\&.
.SS "#define END_ORIENT_TEMP   (1866)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB77\fP 行定义\&.
.SS "#define END_PREDICTION_UPDATE   (1761)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB82\fP 行定义\&.
.SS "#define fabs   fabsf"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB61\fP 行定义\&.
.SS "#define FCFG_1   (1062)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB93\fP 行定义\&.
.SS "#define FCFG_2   (1066)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB92\fP 行定义\&.
.SS "#define FCFG_3   (1088)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB91\fP 行定义\&.
.SS "#define FCFG_6   (1106)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB96\fP 行定义\&.
.SS "#define FCFG_7   (1073)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB95\fP 行定义\&.
.SS "#define FIFO_CORRUPTION_CHECK"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB473\fP 行定义\&.
.SS "#define FLAT_STATE_END   (1713)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB97\fP 行定义\&.
.SS "#define FLAT_STATE_END_TEMP   (1683)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB109\fP 行定义\&.
.SS "#define FLICK_COUNTER   (45 * 16 + 8)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB206\fP 行定义\&.
.SS "#define FLICK_LOWER   (45 * 16 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB207\fP 行定义\&.
.SS "#define FLICK_MSG   (45 * 16 + 4)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB205\fP 行定义\&.
.SS "#define FLICK_UPPER   (46 * 16 + 12)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB208\fP 行定义\&.
.SS "#define get_ms   \fBmget_ms\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB50\fP 行定义\&.
.SS "#define get_ms   \fBmget_ms\fP"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB42\fP 行定义\&.
.SS "#define GYRO_SF   (46850825LL * 200 / \fBDMP_SAMPLE_RATE\fP)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB471\fP 行定义\&.
.SS "#define i2c_read   \fBMPU_Read_Len\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB48\fP 行定义\&.
.SS "#define i2c_write   \fBMPU_Write_Len\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB47\fP 行定义\&.
.SS "#define INT_SRC_ANDROID_ORIENT   (0x08)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB463\fP 行定义\&.
.SS "#define INT_SRC_TAP   (0x01)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB462\fP 行定义\&.
.SS "#define INV_WXYZ_QUAT   (0x100)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB50\fP 行定义\&.
.SS "#define INV_X_GYRO   (0x40)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB29\fP 行定义\&.
.SS "#define INV_XYZ_ACCEL   (0x08)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB33\fP 行定义\&.
.SS "#define INV_XYZ_COMPASS   (0x01)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB34\fP 行定义\&.
.SS "#define INV_XYZ_GYRO   (\fBINV_X_GYRO\fP | \fBINV_Y_GYRO\fP | \fBINV_Z_GYRO\fP)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB32\fP 行定义\&.
.SS "#define INV_Y_GYRO   (0x20)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB30\fP 行定义\&.
.SS "#define INV_Z_GYRO   (0x10)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB31\fP 行定义\&.
.SS "#define log_e   \fBlog_none\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB58\fP 行定义\&.
.SS "#define log_e   printf"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB44\fP 行定义\&.
.SS "#define log_i   \fBlog_none\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB57\fP 行定义\&.
.SS "#define log_i   printf"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB43\fP 行定义\&.
.SS "#define MAX_PACKET_LENGTH   (12)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB667\fP 行定义\&.
.SS "#define MAX_PACKET_LENGTH   (32)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB468\fP 行定义\&.
.SS "#define min(a, b)   ((a<b)?a:b)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB62\fP 行定义\&.
.SS "#define MOTION_DRIVER_TARGET_MSP430"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB31\fP 行定义\&.
.SS "#define MOTION_DRIVER_TARGET_MSP430"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB28\fP 行定义\&.
.SS "#define MPU6050"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB30\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DATA_READY   (0x0001)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB50\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DMP   (0x0002)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB51\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DMP_0   (0x0100)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB58\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DMP_1   (0x0200)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB59\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DMP_2   (0x0400)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB60\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DMP_3   (0x0800)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB61\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DMP_4   (0x1000)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB62\fP 行定义\&.
.SS "#define MPU_INT_STATUS_DMP_5   (0x2000)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB63\fP 行定义\&.
.SS "#define MPU_INT_STATUS_FIFO_OVERFLOW   (0x0010)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB54\fP 行定义\&.
.SS "#define MPU_INT_STATUS_FREE_FALL   (0x0080)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB57\fP 行定义\&.
.SS "#define MPU_INT_STATUS_I2C_MST   (0x0008)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB53\fP 行定义\&.
.SS "#define MPU_INT_STATUS_MOT   (0x0040)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB56\fP 行定义\&.
.SS "#define MPU_INT_STATUS_PLL_READY   (0x0004)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB52\fP 行定义\&.
.SS "#define MPU_INT_STATUS_ZMOT   (0x0020)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB55\fP 行定义\&.
.SS "#define q30   1073741824\&.0f"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2865\fP 行定义\&.
.SS "#define QUAT_ERROR_THRESH   (1L<<24)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB475\fP 行定义\&.
.SS "#define QUAT_MAG_SQ_MAX   (\fBQUAT_MAG_SQ_NORMALIZED\fP + \fBQUAT_ERROR_THRESH\fP)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB478\fP 行定义\&.
.SS "#define QUAT_MAG_SQ_MIN   (\fBQUAT_MAG_SQ_NORMALIZED\fP \- \fBQUAT_ERROR_THRESH\fP)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB477\fP 行定义\&.
.SS "#define QUAT_MAG_SQ_NORMALIZED   (1L<<28)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB476\fP 行定义\&.
.SS "#define SKIP_END_COMPARE   (1435)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB90\fP 行定义\&.
.SS "#define SKIP_SWING_END_1   (1551)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB111\fP 行定义\&.
.SS "#define SKIP_SWING_END_2   (1566)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB113\fP 行定义\&.
.SS "#define SKIP_SWING_END_3   (1588)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB112\fP 行定义\&.
.SS "#define SKIP_X_GRT_Y_TMP   (1359)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB89\fP 行定义\&.
.SS "#define SWING_END_1   (1550)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB101\fP 行定义\&.
.SS "#define SWING_END_2   (1565)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB99\fP 行定义\&.
.SS "#define SWING_END_3   (1587)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB100\fP 行定义\&.
.SS "#define SWING_END_4   (1616)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB98\fP 行定义\&.
.SS "#define TAP_X   (0x01)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB20\fP 行定义\&.
.SS "#define TAP_X_DOWN   (0x02)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB26\fP 行定义\&.
.SS "#define TAP_X_UP   (0x01)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB25\fP 行定义\&.
.SS "#define TAP_XYZ   (0x07)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB23\fP 行定义\&.
.SS "#define TAP_Y   (0x02)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB21\fP 行定义\&.
.SS "#define TAP_Y_DOWN   (0x04)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB28\fP 行定义\&.
.SS "#define TAP_Y_UP   (0x03)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB27\fP 行定义\&.
.SS "#define TAP_Z   (0x04)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB22\fP 行定义\&.
.SS "#define TAP_Z_DOWN   (0x06)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB30\fP 行定义\&.
.SS "#define TAP_Z_UP   (0x05)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.h\fP 第 \fB29\fP 行定义\&.
.SS "#define TEMPLABEL   (2324)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB122\fP 行定义\&.
.SS "#define TILTG75_START   (1672)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB114\fP 行定义\&.
.SS "#define TILTL75_END   (1669)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB116\fP 行定义\&.
.SS "#define TILTL75_START   (1643)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB119\fP 行定义\&.
.SS "#define UPDATE_PROP_ROT   (1835)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB87\fP 行定义\&.
.SS "#define X_GRT_Y   (1408)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB121\fP 行定义\&.
.SS "#define X_GRT_Y_TMP   (1358)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB84\fP 行定义\&.
.SS "#define X_GRT_Y_TMP2   (1379)"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB125\fP 行定义\&.
.SH "枚举类型说明"
.PP 
.SS "enum \fBaccel_fsr_e\fP"

.PP
\fB枚举值\fP
.in +1c
.TP
\fB\fIINV_FSR_2G \fP\fP
.TP
\fB\fIINV_FSR_4G \fP\fP
.TP
\fB\fIINV_FSR_8G \fP\fP
.TP
\fB\fIINV_FSR_16G \fP\fP
.TP
\fB\fINUM_ACCEL_FSR \fP\fP
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB329\fP 行定义\&.
.SS "enum \fBclock_sel_e\fP"

.PP
\fB枚举值\fP
.in +1c
.TP
\fB\fIINV_CLK_INTERNAL \fP\fP
.TP
\fB\fIINV_CLK_PLL \fP\fP
.TP
\fB\fINUM_CLK \fP\fP
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB338\fP 行定义\&.
.SS "enum \fBgyro_fsr_e\fP"

.PP
\fB枚举值\fP
.in +1c
.TP
\fB\fIINV_FSR_250DPS \fP\fP
.TP
\fB\fIINV_FSR_500DPS \fP\fP
.TP
\fB\fIINV_FSR_1000DPS \fP\fP
.TP
\fB\fIINV_FSR_2000DPS \fP\fP
.TP
\fB\fINUM_GYRO_FSR \fP\fP
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB320\fP 行定义\&.
.SS "enum \fBlp_accel_rate_e\fP"

.PP
\fB枚举值\fP
.in +1c
.TP
\fB\fIINV_LPA_1_25HZ \fP\fP
.TP
\fB\fIINV_LPA_5HZ \fP\fP
.TP
\fB\fIINV_LPA_20HZ \fP\fP
.TP
\fB\fIINV_LPA_40HZ \fP\fP
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB345\fP 行定义\&.
.SS "enum \fBlpf_e\fP"

.PP
\fB枚举值\fP
.in +1c
.TP
\fB\fIINV_FILTER_256HZ_NOLPF2 \fP\fP
.TP
\fB\fIINV_FILTER_188HZ \fP\fP
.TP
\fB\fIINV_FILTER_98HZ \fP\fP
.TP
\fB\fIINV_FILTER_42HZ \fP\fP
.TP
\fB\fIINV_FILTER_20HZ \fP\fP
.TP
\fB\fIINV_FILTER_10HZ \fP\fP
.TP
\fB\fIINV_FILTER_5HZ \fP\fP
.TP
\fB\fIINV_FILTER_2100HZ_NOLPF \fP\fP
.TP
\fB\fINUM_FILTER \fP\fP
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB307\fP 行定义\&.
.SH "函数说明"
.PP 
.SS "static int accel_self_test (long * bias_regular, long * bias_st)\fC [static]\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1925\fP 行定义\&.
.SS "static int decode_gesture (unsigned char * gesture)\fC [static]\fP"

.PP
Decode the four-byte gesture data and execute any callbacks\&. 
.PP
\fB参数\fP
.RS 4
\fIgesture\fP Gesture data from DMP packet\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1197\fP 行定义\&.
.SS "int dmp_enable_6x_lp_quat (unsigned char enable)"

.PP
Generate 6-axis quaternions from the DMP\&. In this driver, the 3-axis and 6-axis DMP quaternion features are mutually exclusive\&. 
.PP
\fB参数\fP
.RS 4
\fIenable\fP 1 to enable 6-axis quaternion\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1176\fP 行定义\&.
.SS "int dmp_enable_feature (unsigned short mask)"

.PP
Enable DMP features\&. The following #define's are used in the input mask: 
.br
 DMP_FEATURE_TAP 
.br
 DMP_FEATURE_ANDROID_ORIENT 
.br
 DMP_FEATURE_LP_QUAT 
.br
 DMP_FEATURE_6X_LP_QUAT 
.br
 DMP_FEATURE_GYRO_CAL 
.br
 DMP_FEATURE_SEND_RAW_ACCEL 
.br
 DMP_FEATURE_SEND_RAW_GYRO 
.br
 NOTE: DMP_FEATURE_LP_QUAT and DMP_FEATURE_6X_LP_QUAT are mutually exclusive\&. 
.br
 NOTE: DMP_FEATURE_SEND_RAW_GYRO and DMP_FEATURE_SEND_CAL_GYRO are also mutually exclusive\&. 
.PP
\fB参数\fP
.RS 4
\fImask\fP Mask of features to enable\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB997\fP 行定义\&.
.SS "int dmp_enable_gyro_cal (unsigned char enable)"

.PP
Calibrate the gyro data in the DMP\&. After eight seconds of no motion, the DMP will compute gyro biases and subtract them from the quaternion output\&. If \fIdmp_enable_feature\fP is called with \fIDMP_FEATURE_SEND_CAL_GYRO\fP, the biases will also be subtracted from the gyro output\&. 
.PP
\fB参数\fP
.RS 4
\fIenable\fP 1 to enable gyro calibration\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1134\fP 行定义\&.
.SS "int dmp_enable_lp_quat (unsigned char enable)"

.PP
Generate 3-axis quaternions from the DMP\&. In this driver, the 3-axis and 6-axis DMP quaternion features are mutually exclusive\&. 
.PP
\fB参数\fP
.RS 4
\fIenable\fP 1 to enable 3-axis quaternion\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1152\fP 行定义\&.
.SS "int dmp_get_enabled_features (unsigned short * mask)"

.PP
Get list of currently enabled DMP features\&. 
.PP
\fB参数\fP
.RS 4
\fIMask\fP of enabled features\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1119\fP 行定义\&.
.SS "int dmp_get_fifo_rate (unsigned short * rate)"

.PP
Get DMP output rate\&. 
.PP
\fB参数\fP
.RS 4
\fIrate\fP Current fifo rate (Hz)\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB710\fP 行定义\&.
.SS "int dmp_get_pedometer_step_count (unsigned long * count)"

.PP
Get current step count\&. 
.PP
\fB参数\fP
.RS 4
\fIcount\fP Number of steps detected\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB910\fP 行定义\&.
.SS "int dmp_get_pedometer_walk_time (unsigned long * time)"

.PP
Get duration of walking time\&. 
.PP
\fB参数\fP
.RS 4
\fItime\fP Walk time in milliseconds\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB947\fP 行定义\&.
.SS "int dmp_load_motion_driver_firmware (void)"

.PP
Load the DMP with this image\&. 
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB512\fP 行定义\&.
.SS "int dmp_read_fifo (short * gyro, short * accel, long * quat, unsigned long * timestamp, short * sensors, unsigned char * more)"

.PP
Get one packet from the FIFO\&. If \fIsensors\fP does not contain a particular sensor, disregard the data returned to that pointer\&. 
.br
 \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.br
 INV_WXYZ_QUAT 
.br
 If the FIFO has no new data, \fIsensors\fP will be zero\&. 
.br
 If the FIFO is disabled, \fIsensors\fP will be zero and this function will return a non-zero error code\&. 
.PP
\fB参数\fP
.RS 4
\fIgyro\fP Gyro data in hardware units\&. 
.br
\fIaccel\fP Accel data in hardware units\&. 
.br
\fIquat\fP 3-axis quaternion data in hardware units\&. 
.br
\fItimestamp\fP Timestamp in milliseconds\&. 
.br
\fIsensors\fP Mask of sensors read from FIFO\&. 
.br
\fImore\fP Number of remaining packets\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1268\fP 行定义\&.
.SS "int dmp_register_android_orient_cb (void(*)(unsigned char) func)"

.PP
Register a function to be executed on a android orientation event\&. 
.PP
\fB参数\fP
.RS 4
\fIfunc\fP Callback function\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1372\fP 行定义\&.
.SS "int dmp_register_tap_cb (void(*)(unsigned char, unsigned char) func)"

.PP
Register a function to be executed on a tap event\&. The tap direction is represented by one of the following: 
.br
 TAP_X_UP 
.br
 TAP_X_DOWN 
.br
 TAP_Y_UP 
.br
 TAP_Y_DOWN 
.br
 TAP_Z_UP 
.br
 TAP_Z_DOWN 
.PP
\fB参数\fP
.RS 4
\fIfunc\fP Callback function\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1361\fP 行定义\&.
.SS "int dmp_set_accel_bias (long * bias)"

.PP
Push accel biases to the DMP\&. These biases will be removed from the DMP 6-axis quaternion\&. 
.PP
\fB参数\fP
.RS 4
\fIbias\fP Accel biases in q16\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB632\fP 行定义\&.
.SS "int dmp_set_fifo_rate (unsigned short rate)"

.PP
Set DMP output rate\&. Only used when DMP is on\&. 
.PP
\fB参数\fP
.RS 4
\fIrate\fP Desired fifo rate (Hz)\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB684\fP 行定义\&.
.SS "int dmp_set_gyro_bias (long * bias)"

.PP
Push gyro biases to the DMP\&. Because the gyro integration is handled in the DMP, any gyro biases calculated by the MPL should be pushed down to DMP memory to remove 3-axis quaternion drift\&. 
.br
 NOTE: If the DMP-based gyro calibration is enabled, the DMP will overwrite the biases written to this location once a new one is computed\&. 
.PP
\fB参数\fP
.RS 4
\fIbias\fP Gyro biases in q16\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB580\fP 行定义\&.
.SS "int dmp_set_interrupt_mode (unsigned char mode)"

.PP
Specify when a DMP interrupt should occur\&. A DMP interrupt can be configured to trigger on either of the two conditions below: 
.br
 a\&. One FIFO period has elapsed (set by \fImpu_set_sample_rate\fP)\&. 
.br
 b\&. A tap event has been detected\&. 
.PP
\fB参数\fP
.RS 4
\fImode\fP DMP_INT_GESTURE or DMP_INT_CONTINUOUS\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB1229\fP 行定义\&.
.SS "int dmp_set_orientation (unsigned short orient)"

.PP
Push gyro and accel orientation to the DMP\&. The orientation is represented here as the output of \fIinv_orientation_matrix_to_scalar\fP\&. 
.PP
\fB参数\fP
.RS 4
\fIorient\fP Gyro and accel orientation in body frame\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB525\fP 行定义\&.
.SS "int dmp_set_pedometer_step_count (unsigned long count)"

.PP
Overwrite current step count\&. WARNING: This function writes to DMP memory and could potentially encounter a race condition if called while the pedometer is enabled\&. 
.PP
\fB参数\fP
.RS 4
\fIcount\fP New step count\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB931\fP 行定义\&.
.SS "int dmp_set_pedometer_walk_time (unsigned long time)"

.PP
Overwrite current walk time\&. WARNING: This function writes to DMP memory and could potentially encounter a race condition if called while the pedometer is enabled\&. 
.PP
\fB参数\fP
.RS 4
\fItime\fP New walk time in milliseconds\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB967\fP 行定义\&.
.SS "int dmp_set_shake_reject_thresh (long sf, unsigned short thresh)"

.PP
Set shake rejection threshold\&. If the DMP detects a gyro sample larger than \fIthresh\fP, taps are rejected\&. 
.PP
\fB参数\fP
.RS 4
\fIsf\fP Gyro scale factor\&. 
.br
\fIthresh\fP Gyro threshold in dps\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB858\fP 行定义\&.
.SS "int dmp_set_shake_reject_time (unsigned short time)"

.PP
Set shake rejection time\&. Sets the length of time that the gyro must be outside of the threshold set by \fIgyro_set_shake_reject_thresh\fP before taps are rejected\&. A mandatory 60 ms is added to this parameter\&. 
.PP
\fB参数\fP
.RS 4
\fItime\fP Time in milliseconds\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB877\fP 行定义\&.
.SS "int dmp_set_shake_reject_timeout (unsigned short time)"

.PP
Set shake rejection timeout\&. Sets the length of time after a shake rejection that the gyro must stay inside of the threshold before taps can be detected again\&. A mandatory 60 ms is added to this parameter\&. 
.PP
\fB参数\fP
.RS 4
\fItime\fP Time in milliseconds\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB895\fP 行定义\&.
.SS "int dmp_set_tap_axes (unsigned char axis)"

.PP
Set which axes will register a tap\&. 
.PP
\fB参数\fP
.RS 4
\fIaxis\fP 1, 2, and 4 for XYZ, respectively\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB788\fP 行定义\&.
.SS "int dmp_set_tap_count (unsigned char min_taps)"

.PP
Set minimum number of taps needed for an interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fImin_taps\fP Minimum consecutive taps (1-4)\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB806\fP 行定义\&.
.SS "int dmp_set_tap_thresh (unsigned char axis, unsigned short thresh)"

.PP
Set tap threshold for a specific axis\&. 
.PP
\fB参数\fP
.RS 4
\fIaxis\fP 1, 2, and 4 for XYZ accel, respectively\&. 
.br
\fIthresh\fP Tap threshold, in mg/ms\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB722\fP 行定义\&.
.SS "int dmp_set_tap_time (unsigned short time)"

.PP
Set length between valid taps\&. 
.PP
\fB参数\fP
.RS 4
\fItime\fP Milliseconds between taps\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB824\fP 行定义\&.
.SS "int dmp_set_tap_time_multi (unsigned short time)"

.PP
Set max time between taps to register as a multi-tap\&. 
.PP
\fB参数\fP
.RS 4
\fItime\fP Max milliseconds between taps\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB840\fP 行定义\&.
.SS "static int get_accel_prod_shift (float * st_shift)\fC [static]\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1900\fP 行定义\&.
.SS "static int get_st_biases (long * gyro, long * accel, unsigned char hw_test)\fC [static]\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2029\fP 行定义\&.
.SS "static int gyro_self_test (long * bias_regular, long * bias_st)\fC [static]\fP"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1945\fP 行定义\&.
.SS "unsigned short inv_orientation_matrix_to_scalar (const signed char * mtx)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2898\fP 行定义\&.
.SS "unsigned short inv_row_2_scale (const signed char * row)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2914\fP 行定义\&.
.SS "void log_none (char * fmt,  \&.\&.\&.)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB56\fP 行定义\&.
.SS "void mget_ms (unsigned long * time)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2933\fP 行定义\&.
.SS "int mpu_configure_fifo (unsigned char sensors)"

.PP
Select which sensors are pushed to FIFO\&. \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.PP
\fB参数\fP
.RS 4
\fIsensors\fP Mask of sensors to push to FIFO\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1531\fP 行定义\&.
.SS "\fBu8\fP mpu_dmp_get_data (float * pitch, float * roll, float * yaw)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2970\fP 行定义\&.
.SS "\fBu8\fP mpu_dmp_init (void)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2937\fP 行定义\&.
.SS "int mpu_get_accel_fsr (unsigned char * fsr)"

.PP
Get the accel full-scale range\&. 
.PP
\fB参数\fP
.RS 4
\fIfsr\fP Current full-scale range\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1218\fP 行定义\&.
.SS "int mpu_get_accel_reg (short * data, unsigned long * timestamp)"

.PP
Read raw accel data directly from the registers\&. 
.PP
\fB参数\fP
.RS 4
\fIdata\fP Raw data in hardware units\&. 
.br
\fItimestamp\fP Timestamp in milliseconds\&. Null if not needed\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB995\fP 行定义\&.
.SS "int mpu_get_accel_sens (unsigned short * sens)"

.PP
Get accel sensitivity scale factor\&. 
.PP
\fB参数\fP
.RS 4
\fIsens\fP Conversion from hardware units to g's\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1484\fP 行定义\&.
.SS "int mpu_get_compass_fsr (unsigned short * fsr)"

.PP
Get the compass full-scale range\&. 
.PP
\fB参数\fP
.RS 4
\fIfsr\fP Current full-scale range\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2588\fP 行定义\&.
.SS "int mpu_get_compass_reg (short * data, unsigned long * timestamp)"

.PP
Read raw compass data\&. 
.PP
\fB参数\fP
.RS 4
\fIdata\fP Raw data in hardware units\&. 
.br
\fItimestamp\fP Timestamp in milliseconds\&. Null if not needed\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2535\fP 行定义\&.
.SS "int mpu_get_compass_sample_rate (unsigned short * rate)"

.PP
Get compass sampling rate\&. 
.PP
\fB参数\fP
.RS 4
\fIrate\fP Current compass sampling rate (Hz)\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1414\fP 行定义\&.
.SS "int mpu_get_dmp_state (unsigned char * enabled)"

.PP
Get DMP state\&. 
.PP
\fB参数\fP
.RS 4
\fIenabled\fP 1 if enabled\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2416\fP 行定义\&.
.SS "int mpu_get_fifo_config (unsigned char * sensors)"

.PP
Get current FIFO configuration\&. \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.PP
\fB参数\fP
.RS 4
\fIsensors\fP Mask of sensors in FIFO\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1516\fP 行定义\&.
.SS "int mpu_get_gyro_fsr (unsigned short * fsr)"

.PP
Get the gyro full-scale range\&. 
.PP
\fB参数\fP
.RS 4
\fIfsr\fP Current full-scale range\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1154\fP 行定义\&.
.SS "int mpu_get_gyro_reg (short * data, unsigned long * timestamp)"

.PP
Read raw gyro data directly from the registers\&. 
.PP
\fB参数\fP
.RS 4
\fIdata\fP Raw data in hardware units\&. 
.br
\fItimestamp\fP Timestamp in milliseconds\&. Null if not needed\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB972\fP 行定义\&.
.SS "int mpu_get_gyro_sens (float * sens)"

.PP
Get gyro sensitivity scale factor\&. 
.PP
\fB参数\fP
.RS 4
\fIsens\fP Conversion from hardware units to dps\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1458\fP 行定义\&.
.SS "int mpu_get_int_status (short * status)"

.PP
Read the MPU interrupt status registers\&. 
.PP
\fB参数\fP
.RS 4
\fIstatus\fP Mask of interrupt bits\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1669\fP 行定义\&.
.SS "int mpu_get_lpf (unsigned short * lpf)"

.PP
Get the current DLPF setting\&. 
.PP
\fB参数\fP
.RS 4
\fIlpf\fP Current LPF setting\&. 0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1283\fP 行定义\&.
.SS "int mpu_get_power_state (unsigned char * power_on)"

.PP
Get current power state\&. 
.PP
\fB参数\fP
.RS 4
\fIpower_on\fP 1 if turned on, 0 if suspended\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1573\fP 行定义\&.
.SS "int mpu_get_sample_rate (unsigned short * rate)"

.PP
Get sampling rate\&. 
.PP
\fB参数\fP
.RS 4
\fIrate\fP Current sampling rate (Hz)\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1352\fP 行定义\&.
.SS "int mpu_get_temperature (long * data, unsigned long * timestamp)"

.PP
Read temperature data directly from the registers\&. 
.PP
\fB参数\fP
.RS 4
\fIdata\fP Data in q16 format\&. 
.br
\fItimestamp\fP Timestamp in milliseconds\&. Null if not needed\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1018\fP 行定义\&.
.SS "int mpu_init (void)"

.PP
Initialize hardware\&. Initial configuration:
.br
Gyro FSR: +/- 2000DPS
.br
Accel FSR +/- 2G
.br
DLPF: 42Hz
.br
FIFO rate: 50Hz
.br
Clock source: Gyro PLL
.br
FIFO: Disabled\&.
.br
Data ready interrupt: Disabled, active low, unlatched\&. 
.PP
\fB参数\fP
.RS 4
\fIint_param\fP Platform-specific parameters to interrupt API\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB757\fP 行定义\&.
.SS "int mpu_init_slave (void)"

.SS "int mpu_load_firmware (unsigned short length, const unsigned char * firmware, unsigned short start_addr, unsigned short sample_rate)"

.PP
Load and verify DMP image\&. 
.PP
\fB参数\fP
.RS 4
\fIlength\fP Length of DMP image\&. 
.br
\fIfirmware\fP DMP code\&. 
.br
\fIstart_addr\fP Starting address of DMP code memory\&. 
.br
\fIsample_rate\fP Fixed sampling rate used when DMP is enabled\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2336\fP 行定义\&.
.SS "int mpu_lp_accel_mode (unsigned char rate)"

.PP
Enter low-power accel-only mode\&. In low-power accel mode, the chip goes to sleep and only wakes up to sample the accelerometer at one of the following frequencies: 
.br
 MPU6050: 1\&.25Hz, 5Hz, 20Hz, 40Hz 
.br
 MPU6500: 1\&.25Hz, 2\&.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz 
.br
 If the requested rate is not one listed above, the device will be set to the next highest rate\&. Requesting a rate above the maximum supported frequency will result in an error\&. 
.br
 To select a fractional wake-up frequency, round down the value passed to \fIrate\fP\&. 
.PP
\fB参数\fP
.RS 4
\fIrate\fP Minimum sampling rate, or zero to disable LP accel mode\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB888\fP 行定义\&.
.SS "int mpu_lp_motion_interrupt (unsigned short thresh, unsigned char time, unsigned char lpa_freq)"

.PP
Enters LP accel motion interrupt mode\&. The behavior of this feature is very different between the MPU6050 and the MPU6500\&. Each chip's version of this feature is explained below\&. 
.br
 MPU6050: 
.br
 When this mode is first enabled, the hardware captures a single accel sample, and subsequent samples are compared with this one to determine if the device is in motion\&. Therefore, whenever this 'locked' sample needs to be changed, this function must be called again\&.
.PP

.br
 The hardware motion threshold can be between 32mg and 8160mg in 32mg increments\&.
.PP

.br
 Low-power accel mode supports the following frequencies: 
.br
 1\&.25Hz, 5Hz, 20Hz, 40Hz
.PP

.br
 MPU6500: 
.br
 Unlike the MPU6050 version, the hardware does not 'lock in' a reference sample\&. The hardware monitors the accel data and detects any large change over a short period of time\&.
.PP

.br
 The hardware motion threshold can be between 4mg and 1020mg in 4mg increments\&.
.PP

.br
 MPU6500 Low-power accel mode supports the following frequencies: 
.br
 1\&.25Hz, 2\&.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
.PP

.br

.br
 NOTES: 
.br
 The driver will round down \fIthresh\fP to the nearest supported value if an unsupported threshold is selected\&. 
.br
 To select a fractional wake-up frequency, round down the value passed to \fIlpa_freq\fP\&. 
.br
 The MPU6500 does not support a delay parameter\&. If this function is used for the MPU6500, the value passed to \fItime\fP will be ignored\&. 
.br
 To disable this mode, set \fIlpa_freq\fP to zero\&. The driver will restore the previous configuration\&.
.PP
\fB参数\fP
.RS 4
\fIthresh\fP Motion threshold in mg\&. 
.br
\fItime\fP Duration in milliseconds that the accel data must exceed \fIthresh\fP before motion is reported\&. 
.br
\fIlpa_freq\fP Minimum sampling rate, or zero to disable\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2642\fP 行定义\&.
.SS "int mpu_read_fifo (short * gyro, short * accel, unsigned long * timestamp, unsigned char * sensors, unsigned char * more)"

.PP
Get one packet from the FIFO\&. If \fIsensors\fP does not contain a particular sensor, disregard the data returned to that pointer\&. 
.br
 \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.br
 If the FIFO has no new data, \fIsensors\fP will be zero\&. 
.br
 If the FIFO is disabled, \fIsensors\fP will be zero and this function will return a non-zero error code\&. 
.PP
\fB参数\fP
.RS 4
\fIgyro\fP Gyro data in hardware units\&. 
.br
\fIaccel\fP Accel data in hardware units\&. 
.br
\fItimestamp\fP Timestamp in milliseconds\&. 
.br
\fIsensors\fP Mask of sensors read from FIFO\&. 
.br
\fImore\fP Number of remaining packets\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1698\fP 行定义\&.
.SS "int mpu_read_fifo_stream (unsigned short length, unsigned char * data, unsigned char * more)"

.PP
Get one unparsed packet from the FIFO\&. This function should be used if the packet is to be parsed elsewhere\&. 
.PP
\fB参数\fP
.RS 4
\fIlength\fP Length of one FIFO packet\&. 
.br
\fIdata\fP FIFO packet\&. 
.br
\fImore\fP Number of remaining packets\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1779\fP 行定义\&.
.SS "int mpu_read_mem (unsigned short mem_addr, unsigned short length, unsigned char * data)"

.PP
Read from the DMP memory\&. This function prevents I2C reads past the bank boundaries\&. The DMP memory is only accessible when the chip is awake\&. 
.PP
\fB参数\fP
.RS 4
\fImem_addr\fP Memory location (bank << 8 | start address) 
.br
\fIlength\fP Number of bytes to read\&. 
.br
\fIdata\fP Bytes read from memory\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2304\fP 行定义\&.
.SS "int mpu_read_reg (unsigned char reg, unsigned char * data)"

.PP
Read from a single register\&. NOTE: The memory and FIFO read/write registers cannot be accessed\&. 
.PP
\fB参数\fP
.RS 4
\fIreg\fP Register address\&. 
.br
\fIdata\fP Register data\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB735\fP 行定义\&.
.SS "int mpu_reg_dump (void)"

.PP
Register dump for testing\&. 
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB713\fP 行定义\&.
.SS "int mpu_register_tap_cb (void(*)(unsigned char, unsigned char) func)"

.SS "int mpu_reset_fifo (void)"

.PP
Reset FIFO read/write pointers\&. 
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1092\fP 行定义\&.
.SS "int mpu_run_self_test (long * gyro, long * accel)"

.PP
Trigger gyro/accel/compass self-test\&. On success/error, the self-test returns a mask representing the sensor(s) that failed\&. For each bit, a one (1) represents a 'pass' case; conversely, a zero (0) indicates a failure\&. 
.br
 The mask is defined as follows: 
.br
 Bit 0: Gyro\&. 
.br
 Bit 1: Accel\&. 
.br
 Bit 2: Compass\&.
.PP

.br
 Currently, the hardware self-test is unsupported for MPU6500\&. However, this function can still be used to obtain the accel and gyro biases\&.
.PP

.br
 This function must be called with the device either face-up or face-down (z-axis is parallel to gravity)\&. 
.PP
\fB参数\fP
.RS 4
\fIgyro\fP Gyro biases in q16 format\&. 
.br
\fIaccel\fP Accel biases (if applicable) in q16 format\&. 
.RE
.PP
\fB返回\fP
.RS 4
Result mask (see above)\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2169\fP 行定义\&.
.SS "int mpu_set_accel_bias (const long * accel_bias)"

.PP
Push biases to the accel bias registers\&. This function expects biases relative to the current sensor output, and these biases will be added to the factory-supplied values\&. 
.PP
\fB参数\fP
.RS 4
\fIaccel_bias\fP New biases\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1043\fP 行定义\&.
.SS "int mpu_set_accel_fsr (unsigned char fsr)"

.PP
Set the accel full-scale range\&. 
.PP
\fB参数\fP
.RS 4
\fIfsr\fP Desired full-scale range\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1246\fP 行定义\&.
.SS "int mpu_set_bypass (unsigned char bypass_on)"

.PP
Set device to bypass mode\&. 
.PP
\fB参数\fP
.RS 4
\fIbypass_on\fP 1 to enable bypass mode\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1817\fP 行定义\&.
.SS "int mpu_set_compass_sample_rate (unsigned short rate)"

.PP
Set compass sampling rate\&. The compass on the auxiliary I2C bus is read by the MPU hardware at a maximum of 100Hz\&. The actual rate can be set to a fraction of the gyro sampling rate\&. 
.br
 WARNING: The new rate may be different than what was requested\&. Call mpu_get_compass_sample_rate to check the actual setting\&. 
.PP
\fB参数\fP
.RS 4
\fIrate\fP Desired compass sampling rate (Hz)\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1436\fP 行定义\&.
.SS "int mpu_set_dmp_state (unsigned char enable)"

.PP
Enable/disable DMP support\&. 
.PP
\fB参数\fP
.RS 4
\fIenable\fP 1 to turn on the DMP\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2377\fP 行定义\&.
.SS "int mpu_set_gyro_fsr (unsigned short fsr)"

.PP
Set the gyro full-scale range\&. 
.PP
\fB参数\fP
.RS 4
\fIfsr\fP Desired full-scale range\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1181\fP 行定义\&.
.SS "int mpu_set_int_latched (unsigned char enable)"

.PP
Enable latched interrupts\&. Any MPU register will clear the interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fIenable\fP 1 to enable, 0 to disable\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1879\fP 行定义\&.
.SS "int mpu_set_int_level (unsigned char active_low)"

.PP
Set interrupt level\&. 
.PP
\fB参数\fP
.RS 4
\fIactive_low\fP 1 for active low, 0 for active high\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1867\fP 行定义\&.
.SS "int mpu_set_lpf (unsigned short lpf)"

.PP
Set digital low pass filter\&. The following LPF settings are supported: 188, 98, 42, 20, 10, 5\&. 
.PP
\fB参数\fP
.RS 4
\fIlpf\fP Desired LPF setting\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1319\fP 行定义\&.
.SS "int mpu_set_sample_rate (unsigned short rate)"

.PP
Set sampling rate\&. Sampling rate must be between 4Hz and 1kHz\&. 
.PP
\fB参数\fP
.RS 4
\fIrate\fP Desired sampling rate (Hz)\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1367\fP 行定义\&.
.SS "int mpu_set_sensors (unsigned char sensors)"

.PP
Turn specific sensors on/off\&. \fIsensors\fP can contain a combination of the following flags: 
.br
 INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO 
.br
 INV_XYZ_GYRO 
.br
 INV_XYZ_ACCEL 
.br
 INV_XYZ_COMPASS 
.PP
\fB参数\fP
.RS 4
\fIsensors\fP Mask of sensors to wake\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB1592\fP 行定义\&.
.SS "int mpu_write_mem (unsigned short mem_addr, unsigned short length, unsigned char * data)"

.PP
Write to the DMP memory\&. This function prevents I2C writes past the bank boundaries\&. The DMP memory is only accessible when the chip is awake\&. 
.PP
\fB参数\fP
.RS 4
\fImem_addr\fP Memory location (bank << 8 | start address) 
.br
\fIlength\fP Number of bytes to write\&. 
.br
\fIdata\fP Bytes to write to memory\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2271\fP 行定义\&.
.SS "\fBu8\fP run_self_test (void)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2874\fP 行定义\&.
.SS "static int set_int_enable (unsigned char enable)\fC [static]\fP"

.PP
Enable/disable data ready interrupt\&. If the DMP is on, the DMP interrupt is enabled\&. Otherwise, the data ready interrupt is used\&. 
.PP
\fB参数\fP
.RS 4
\fIenable\fP 1 to enable interrupt\&. 
.RE
.PP
\fB返回\fP
.RS 4
0 if successful\&. 
.RE
.PP

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB681\fP 行定义\&.
.SS "int setup_compass (void)"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2424\fP 行定义\&.
.SH "变量说明"
.PP 
.SS "unsigned char gyro_reg_s::accel_cfg"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB164\fP 行定义\&.
.SS "unsigned char motion_int_cache_s::accel_fsr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB223\fP 行定义\&.
.SS "unsigned char chip_cfg_s::accel_fsr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB238\fP 行定义\&.
.SS "unsigned char chip_cfg_s::accel_half"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB256\fP 行定义\&.
.SS "unsigned char gyro_reg_s::accel_offs"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB182\fP 行定义\&.
.SS "unsigned long test_s::accel_sens"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB283\fP 行定义\&.
.SS "unsigned char int_param_s::active_low"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB42\fP 行定义\&.
.SS "unsigned char chip_cfg_s::active_low_int"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB263\fP 行定义\&.
.SS "unsigned char hw_s::addr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB206\fP 行定义\&.
.SS "unsigned char gyro_reg_s::bank_sel"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB184\fP 行定义\&.
.SS "unsigned short hw_s::bank_size"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB211\fP 行定义\&.
.SS "unsigned char chip_cfg_s::bypass_mode"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB251\fP 行定义\&.
.SS "struct \fBmotion_int_cache_s\fP chip_cfg_s::cache"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB261\fP 行定义\&.
.SS "void(* int_param_s::cb) (void)"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB39\fP 行定义\&.
.SS "struct \fBchip_cfg_s\fP gyro_state_s::chip_cfg"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB302\fP 行定义\&.
.SS "unsigned char chip_cfg_s::clk_src"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB243\fP 行定义\&.
.SS "struct \fBdmp_s\fP dmp\fC [static]\fP"
\fB初始值:\fP
.PP
.nf
={
  NULL,
  NULL,
  0,
  0,
  0,
  0
}
.fi
.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB499\fP 行定义\&.
.SS "unsigned char gyro_reg_s::dmp_int_status"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB175\fP 行定义\&.
.SS "unsigned char chip_cfg_s::dmp_loaded"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB269\fP 行定义\&.
.SS "const unsigned char dmp_memory[\fBDMP_CODE_SIZE\fP]\fC [static]\fP"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB250\fP 行定义\&.
.SS "unsigned char motion_int_cache_s::dmp_on"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB228\fP 行定义\&.
.SS "unsigned char chip_cfg_s::dmp_on"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB267\fP 行定义\&.
.SS "unsigned short chip_cfg_s::dmp_sample_rate"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB271\fP 行定义\&.
.SS "unsigned char gyro_reg_s::fifo_count_h"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB169\fP 行定义\&.
.SS "unsigned char gyro_reg_s::fifo_en"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB162\fP 行定义\&.
.SS "unsigned char chip_cfg_s::fifo_enable"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB247\fP 行定义\&.
.SS "unsigned char gyro_reg_s::fifo_r_w"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB170\fP 行定义\&.
.SS "unsigned char motion_int_cache_s::fifo_sensors"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB227\fP 行定义\&.
.SS "unsigned char gyro_reg_s::gyro_cfg"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB163\fP 行定义\&.
.SS "unsigned short motion_int_cache_s::gyro_fsr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB222\fP 行定义\&.
.SS "unsigned char chip_cfg_s::gyro_fsr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB236\fP 行定义\&.
.SS "signed char gyro_orientation[9]\fC [static]\fP"
\fB初始值:\fP
.PP
.nf
= { 1, 0, 0,
                                           0, 1, 0,
                                           0, 0, 1}
.fi
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB2868\fP 行定义\&.
.SS "unsigned long test_s::gyro_sens"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB282\fP 行定义\&.
.SS "const struct \fBhw_s\fP* gyro_state_s::hw"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB301\fP 行定义\&.
.SS "const struct \fBhw_s\fP hw"
\fB初始值:\fP
.PP
.nf
={
  0x68,  
  1024,  
  118,   
  340,   
  -521,  
  256    
}
.fi
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB530\fP 行定义\&.
.SS "unsigned char gyro_reg_s::i2c_mst"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB183\fP 行定义\&.
.SS "unsigned char gyro_reg_s::int_enable"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB174\fP 行定义\&.
.SS "unsigned char chip_cfg_s::int_enable"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB249\fP 行定义\&.
.SS "unsigned char chip_cfg_s::int_motion_only"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB260\fP 行定义\&.
.SS "unsigned char gyro_reg_s::int_pin_cfg"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB180\fP 行定义\&.
.SS "unsigned char gyro_reg_s::int_status"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB176\fP 行定义\&.
.SS "unsigned char chip_cfg_s::latched_int"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB265\fP 行定义\&.
.SS "unsigned char chip_cfg_s::lp_accel_mode"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB258\fP 行定义\&.
.SS "unsigned char int_param_s::lp_exit"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB41\fP 行定义\&.
.SS "unsigned char gyro_reg_s::lpf"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB159\fP 行定义\&.
.SS "unsigned short motion_int_cache_s::lpf"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB224\fP 行定义\&.
.SS "unsigned char chip_cfg_s::lpf"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB242\fP 行定义\&.
.SS "float test_s::max_accel_var"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB295\fP 行定义\&.
.SS "float test_s::max_dps"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB291\fP 行定义\&.
.SS "unsigned short hw_s::max_fifo"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB207\fP 行定义\&.
.SS "float test_s::max_g"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB294\fP 行定义\&.
.SS "float test_s::max_gyro_var"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB292\fP 行定义\&.
.SS "unsigned char gyro_reg_s::mem_r_w"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB181\fP 行定义\&.
.SS "unsigned char gyro_reg_s::mem_start_addr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB185\fP 行定义\&.
.SS "float test_s::min_dps"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB290\fP 行定义\&.
.SS "float test_s::min_g"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB293\fP 行定义\&.
.SS "unsigned char gyro_reg_s::motion_dur"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB168\fP 行定义\&.
.SS "unsigned char gyro_reg_s::motion_thr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB167\fP 行定义\&.
.SS "unsigned char hw_s::num_reg"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB208\fP 行定义\&.
.SS "unsigned char test_s::packet_thresh"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB289\fP 行定义\&.
.SS "unsigned short int_param_s::pin"

.PP
在文件 \fBinv_mpu\&.h\fP 第 \fB40\fP 行定义\&.
.SS "unsigned char gyro_reg_s::prgm_start_h"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB186\fP 行定义\&.
.SS "unsigned char gyro_reg_s::prod_id"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB160\fP 行定义\&.
.SS "unsigned char gyro_reg_s::pwr_mgmt_1"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB178\fP 行定义\&.
.SS "unsigned char gyro_reg_s::pwr_mgmt_2"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB179\fP 行定义\&.
.SS "unsigned char gyro_reg_s::rate_div"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB158\fP 行定义\&.
.SS "unsigned char gyro_reg_s::raw_accel"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB172\fP 行定义\&.
.SS "unsigned char gyro_reg_s::raw_gyro"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB171\fP 行定义\&.
.SS "const struct \fBgyro_reg_s\fP* gyro_state_s::reg"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB300\fP 行定义\&.
.SS "const struct \fBgyro_reg_s\fP reg"
\fB初始值:\fP
.PP
.nf
= {
0x75,  
0x19,  
0x1A,  
0x0C,  
0x6A,  
0x23,  
0x1B,  
0x1C,  
0x1F,  
0x20,  
0x72,  
0x74,  
0x43,  
0x3B,  
0x41,  
0x38,  
0x39,  
0x3A,  
0x6B,  
0x6C,  
0x37,  
0x6F,  
0x06,  
0x24,  
0x6D,  
0x6E,  
0x70   
}
.fi
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB489\fP 行定义\&.
.SS "unsigned char test_s::reg_accel_fsr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB287\fP 行定义\&.
.SS "unsigned char test_s::reg_gyro_fsr"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB286\fP 行定义\&.
.SS "unsigned char test_s::reg_lpf"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB285\fP 行定义\&.
.SS "unsigned char test_s::reg_rate_div"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB284\fP 行定义\&.
.SS "unsigned short motion_int_cache_s::sample_rate"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB225\fP 行定义\&.
.SS "unsigned short chip_cfg_s::sample_rate"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB245\fP 行定义\&.
.SS "unsigned char chip_cfg_s::sensors"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB240\fP 行定义\&.
.SS "unsigned char motion_int_cache_s::sensors_on"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB226\fP 行定义\&.
.SS "const unsigned short sStartAddress = 0x0400\fC [static]\fP"

.PP
在文件 \fBinv_mpu_dmp_motion_driver\&.c\fP 第 \fB458\fP 行定义\&.
.SS "struct \fBgyro_state_s\fP st\fC [static]\fP"
\fB初始值:\fP
.PP
.nf
={
  &reg,
  &hw,
  {0},
  &test
}
.fi
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB577\fP 行定义\&.
.SS "unsigned char gyro_reg_s::temp"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB173\fP 行定义\&.
.SS "short hw_s::temp_offset"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB210\fP 行定义\&.
.SS "unsigned short hw_s::temp_sens"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB209\fP 行定义\&.
.SS "const struct \fBtest_s\fP* gyro_state_s::test"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB303\fP 行定义\&.
.SS "const struct \fBtest_s\fP test"
\fB初始值:\fP
.PP
.nf
={
32768/250,       
32768/16,        
0,               
1,              
0,               
0x18,           
50,             
5,              
10\&.0f,            
105\&.0f,           
0\&.14f,           
0\&.3f,           
0\&.95f,          
0\&.14f           
}
.fi
.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB555\fP 行定义\&.
.SS "unsigned char gyro_reg_s::user_ctrl"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB161\fP 行定义\&.
.SS "unsigned short test_s::wait_ms"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB288\fP 行定义\&.
.SS "unsigned char gyro_reg_s::who_am_i"

.PP
在文件 \fBinv_mpu\&.c\fP 第 \fB157\fP 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 Bscpp 的 源代码自动生成\&.
