.TH "STL_rQueue" 3 "2022年 十一月 22日 星期二" "Version 2.0.0" "MF32BSP_XerolySkinner" \" -*- nroff -*-
.ad l
.nh
.SH NAME
STL_rQueue \- 一个队列的类  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <STL_Queue\&.h>\fP
.SS "Public 成员函数"

.in +1c
.ti -1c
.RI "\fBSTL_rQueue\fP (void)"
.br
.ti -1c
.RI "\fB~STL_rQueue\fP (void)"
.br
.ti -1c
.RI "\fBu8\fP \fBpush\fP (\fBu8\fP var)"
.br
.RI "压入一个成员 "
.ti -1c
.RI "\fBu8\fP \fBpop\fP (void)"
.br
.RI "弹出一个成员 "
.ti -1c
.RI "\fBu8\fP \fBtop\fP (\fBu8\fP &var)"
.br
.RI "显示最后压入的数值 "
.ti -1c
.RI "\fBu32\fP \fBThe_size\fP (void)"
.br
.RI "返回成员数量 "
.ti -1c
.RI "\fBu32\fP \fBThe_room\fP (void)"
.br
.RI "返回占用的内存数 "
.ti -1c
.RI "\fBu8\fP \fBclean\fP (void)"
.br
.RI "将申请的空间比对所需空间,腾出冗余空间 "
.ti -1c
.RI "\fBu8\fP \fBpoptop\fP (void)"
.br
.RI "弹出并且返回一个成员 "
.ti -1c
.RI "\fBu8\fP \fBpush32\fP (\fBu32\fP var)"
.br
.RI "压入一个32位成员 "
.ti -1c
.RI "\fBu32\fP \fBpoptop32\fP (void)"
.br
.RI "弹出并且返回一个32位成员 "
.ti -1c
.RI "void \fBpushfun\fP (void(*fun)(void))"
.br
.RI "压入一个void(*)void函数 "
.in -1c
.SS "Public 属性"

.in +1c
.ti -1c
.RI "void(*)(void) \fBpoptopfun\fP (void)"
.br
.in -1c
.SS "Private 属性"

.in +1c
.ti -1c
.RI "\fBu32\fP \fBroom\fP"
.br
.ti -1c
.RI "\fBu32\fP \fBsize\fP"
.br
.ti -1c
.RI "\fBu8\fP * \fBdat\fP"
.br
.in -1c
.SH "详细描述"
.PP 
一个队列的类 
.PP
在文件 \fBSTL_Queue\&.h\fP 第 \fB57\fP 行定义\&.
.SH "构造及析构函数说明"
.PP 
.SS "STL_rQueue::STL_rQueue (void)"

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB41\fP 行定义\&.
.SS "STL_rQueue::~STL_rQueue (void)"

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB46\fP 行定义\&.
.SH "成员函数说明"
.PP 
.SS "\fBu8\fP STL_rQueue::clean (void)"

.PP
将申请的空间比对所需空间,腾出冗余空间 
.PP
\fB返回\fP
.RS 4
错误号 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB126\fP 行定义\&.
.SS "\fBu8\fP STL_rQueue::pop (void)"

.PP
弹出一个成员 
.PP
\fB返回\fP
.RS 4
错误号 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB82\fP 行定义\&.
.SS "\fBu8\fP STL_rQueue::poptop (void)"

.PP
弹出并且返回一个成员 
.PP
\fB返回\fP
.RS 4
弹出的成员值 
.RE
.PP
\fB注解\fP
.RS 4
该函数不会检查成功与否 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB165\fP 行定义\&.
.SS "\fBu32\fP STL_rQueue::poptop32 (void)"

.PP
弹出并且返回一个32位成员 
.PP
\fB返回\fP
.RS 4
弹出的成员值 
.RE
.PP
\fB注解\fP
.RS 4
该函数不会检查成功与否 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB175\fP 行定义\&.
.SS "\fBu8\fP STL_rQueue::push (\fBu8\fP var)"

.PP
压入一个成员 
.PP
\fB参数\fP
.RS 4
\fIvar\fP 需要压入的数值 
.RE
.PP
\fB返回\fP
.RS 4
错误号 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB56\fP 行定义\&.
.SS "\fBu8\fP STL_rQueue::push32 (\fBu32\fP var)"

.PP
压入一个32位成员 
.PP
\fB参数\fP
.RS 4
\fIvar\fP 需要压入的数值 
.RE
.PP
\fB返回\fP
.RS 4
错误号 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB153\fP 行定义\&.
.SS "void STL_rQueue::pushfun (void(*)(void) fun)"

.PP
压入一个void(*)void函数 
.PP
\fB注解\fP
.RS 4
该函数不会检查成功与否 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB194\fP 行定义\&.
.SS "\fBu32\fP STL_rQueue::The_room (void)"

.PP
返回占用的内存数 
.PP
\fB返回\fP
.RS 4
内存数,u8类型 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB119\fP 行定义\&.
.SS "\fBu32\fP STL_rQueue::The_size (void)"

.PP
返回成员数量 
.PP
\fB返回\fP
.RS 4
成员数量,为u8类型,如u32将占4个元素 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB112\fP 行定义\&.
.SS "\fBu8\fP STL_rQueue::top (\fBu8\fP & var)"

.PP
显示最后压入的数值 
.PP
\fB参数\fP
.RS 4
\fI&var\fP 最后压入数值的储存变量 
.RE
.PP
\fB返回\fP
.RS 4
错误号 
.RE
.PP

.PP
在文件 \fBSTL_Queue\&.cpp\fP 第 \fB102\fP 行定义\&.
.SH "类成员变量说明"
.PP 
.SS "\fBu8\fP* STL_rQueue::dat\fC [private]\fP"

.PP
在文件 \fBSTL_Queue\&.h\fP 第 \fB79\fP 行定义\&.
.SS "void(*)(void) STL_rQueue::poptopfun(void)"

.PP
在文件 \fBSTL_Queue\&.h\fP 第 \fB75\fP 行定义\&.
.SS "\fBu32\fP STL_rQueue::room\fC [private]\fP"

.PP
在文件 \fBSTL_Queue\&.h\fP 第 \fB77\fP 行定义\&.
.SS "\fBu32\fP STL_rQueue::size\fC [private]\fP"

.PP
在文件 \fBSTL_Queue\&.h\fP 第 \fB78\fP 行定义\&.

.SH "作者"
.PP 
由 Doyxgen 通过分析 MF32BSP_XerolySkinner 的 源代码自动生成\&.
