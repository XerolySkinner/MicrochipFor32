.TH "bsp_Integral" 3 "2022年 十一月 27日 星期日" "Version 2.0.0" "MF32BSP_XerolySkinner" \" -*- nroff -*-
.ad l
.nh
.SH NAME
bsp_Integral \- 一个积分对象  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <bsp_Calculus\&.h>\fP
.SS "Public 成员函数"

.in +1c
.ti -1c
.RI "\fBbsp_Integral\fP (float \fBdt\fP)"
.br
.ti -1c
.RI "\fB~bsp_Integral\fP (void)"
.br
.ti -1c
.RI "float \fBIntegral\fP (float var)"
.br
.RI "对数据积分 "
.ti -1c
.RI "void \fBIntegral_set\fP (float \fBresults\fP)"
.br
.RI "重设当前积分值 "
.ti -1c
.RI "float \fBIntegral_list\fP (float var)"
.br
.RI "进行带有缓冲区的积分 "
.ti -1c
.RI "\fBu32\fP \fBIntegral_makelist\fP (\fBu32\fP len)"
.br
.RI "赋予历史缓存长度 "
.ti -1c
.RI "void \fBIntegral_dellist\fP (void)"
.br
.RI "删除并释放历史缓冲区 "
.ti -1c
.RI "void \fBIntegral_clslist\fP (void)"
.br
.RI "清空历史缓存区 "
.in -1c
.SS "Public 属性"

.in +1c
.ti -1c
.RI "float * \fBresult_list\fP"
.br
.RI "数据历史 "
.ti -1c
.RI "\fBu32\fP \fBresult_len\fP"
.br
.RI "历史缓冲区长度 "
.ti -1c
.RI "float \fBresults\fP"
.br
.RI "积分缓存 "
.ti -1c
.RI "float \fBdt\fP"
.br
.RI "时间参数 "
.in -1c
.SH "详细描述"
.PP 
一个积分对象 


.PP
\fB注解\fP
.RS 4
不应当混用Integral和Integral_list 
.PP
选定一种方式(带缓冲区或者不带)后,就不应该更改使用方式 
.PP
虽然带缓冲区方式对算法时间影响不大,但是为了避免浪费空间,不建议使用过大的缓冲区 
.RE
.PP

.PP
在文件 \fBbsp_Calculus\&.h\fP 第 \fB59\fP 行定义\&.
.SH "构造及析构函数说明"
.PP 
.SS "bsp_Integral::bsp_Integral (float dt)\fC [inline]\fP"

.PP
在文件 \fBbsp_Calculus\&.h\fP 第 \fB61\fP 行定义\&.
.SS "bsp_Integral::~bsp_Integral (void)\fC [inline]\fP"

.PP
在文件 \fBbsp_Calculus\&.h\fP 第 \fB65\fP 行定义\&.
.SH "成员函数说明"
.PP 
.SS "float bsp_Integral::Integral (float var)"

.PP
对数据积分 
.PP
\fB参数\fP
.RS 4
\fIvar\fP 此处填入浮点数据 
.RE
.PP
\fB返回\fP
.RS 4
从开始到现在的总积分值 
.RE
.PP

.PP
在文件 \fBbsp_Calculus\&.cpp\fP 第 \fB59\fP 行定义\&.
.SS "void bsp_Integral::Integral_clslist (void)"

.PP
清空历史缓存区 
.PP
在文件 \fBbsp_Calculus\&.cpp\fP 第 \fB113\fP 行定义\&.
.SS "void bsp_Integral::Integral_dellist (void)"

.PP
删除并释放历史缓冲区 
.PP
在文件 \fBbsp_Calculus\&.cpp\fP 第 \fB105\fP 行定义\&.
.SS "float bsp_Integral::Integral_list (float var)"

.PP
进行带有缓冲区的积分 
.PP
\fB参数\fP
.RS 4
\fIvar\fP 需要积分的数值 
.RE
.PP
\fB返回\fP
.RS 4
返回积分值 
.RE
.PP

.PP
在文件 \fBbsp_Calculus\&.cpp\fP 第 \fB86\fP 行定义\&.
.SS "\fBu32\fP bsp_Integral::Integral_makelist (\fBu32\fP len)"

.PP
赋予历史缓存长度 
.PP
\fB参数\fP
.RS 4
\fIvar\fP 分配的缓存长度 
.RE
.PP
\fB返回\fP
.RS 4
返回分配的内存位置,0为分配失败 
.RE
.PP

.PP
在文件 \fBbsp_Calculus\&.cpp\fP 第 \fB75\fP 行定义\&.
.SS "void bsp_Integral::Integral_set (float results)"

.PP
重设当前积分值 
.PP
\fB参数\fP
.RS 4
\fIvar\fP 要设置的积分值 
.RE
.PP

.PP
在文件 \fBbsp_Calculus\&.cpp\fP 第 \fB67\fP 行定义\&.
.SH "类成员变量说明"
.PP 
.SS "float bsp_Integral::dt"

.PP
时间参数 
.PP
在文件 \fBbsp_Calculus\&.h\fP 第 \fB80\fP 行定义\&.
.SS "\fBu32\fP bsp_Integral::result_len"

.PP
历史缓冲区长度 
.PP
在文件 \fBbsp_Calculus\&.h\fP 第 \fB78\fP 行定义\&.
.SS "float* bsp_Integral::result_list"

.PP
数据历史 
.PP
在文件 \fBbsp_Calculus\&.h\fP 第 \fB77\fP 行定义\&.
.SS "float bsp_Integral::results"

.PP
积分缓存 
.PP
在文件 \fBbsp_Calculus\&.h\fP 第 \fB79\fP 行定义\&.

.SH "作者"
.PP 
由 Doyxgen 通过分析 MF32BSP_XerolySkinner 的 源代码自动生成\&.
